<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Tao.Platform.Windows-pre</name>
    </assembly>
    <members>
        <member name="T:Tao.Platform.Windows.Gdi">
            <summary>
                GDI binding for .NET, implementing Windows-specific GDI functionality.
            </summary>
            <remarks>
                Binds functions and definitions in gdi32.dll.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.GDI_NATIVE_LIBRARY">
            <summary>
                Specifies GDI's native library archive.
            </summary>
            <remarks>
                Specifies gdi32.dll for Windows.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.StdCall"/>.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_TYPE_RGBA">
            <summary>
                RGBA pixels.  Each pixel has four components: red, green, blue, and alpha.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_TYPE_COLORINDEX">
            <summary>
                Color-index pixels.  Each pixel uses a color-index value.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_DOUBLEBUFFER">
            <summary>
                The layer plane is double-buffered.  A layer plane can be double-buffered
                even when the main plane is single-buffered and vice versa.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_STEREO">
            <summary>
                The layer plane is stereoscopic.  A layer plane can be stereoscopic even
                when the main plane is monoscopic and vice versa.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SUPPORT_GDI">
            <summary>
                The layer plane supports GDI drawing.  The current implementation of OpenGL
                doesn't support this flag.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SUPPORT_OPENGL">
            <summary>
                The layer plane supports OpenGL drawing.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SHARE_DEPTH">
            <summary>
                The layer plane shares the depth buffer with the main plane.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SHARE_STENCIL">
            <summary>
                The layer plane shares the stencil buffer with the main plane.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SHARE_ACCUM">
            <summary>
                The layer plane shares the accumulation buffer with the main plane.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SWAP_EXCHANGE">
            <summary>
                In a double-buffered layer plane, swapping the color buffer exchanges the
                front buffer and back buffer contents.  The back buffer then contains the
                contents of the front buffer before the swap. This flag is a hint only and
                might not be provided by a driver.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SWAP_COPY">
            <summary>
                In a double-buffered layer plane, swapping the color buffer copies the back
                buffer contents to the front buffer.  The swap does not affect the back
                buffer contents. This flag is a hint only and might not be provided by a driver.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_TRANSPARENT">
            <summary>
                Contains a transparent color or index value that enables underlying layers
                to show through this layer.  All layer planes, except the lowest-numbered
                underlay layer, have a transparent color or index.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_TYPE_RGBA">
            <summary>
                RGBA pixels.  Each pixel has four components in this order: red, green, blue,
                and alpha.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_TYPE_COLORINDEX">
            <summary>
                Color-index pixels.  Each pixel uses a color-index value.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_MAIN_PLANE">
            <summary>
                The layer is the main plane.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_OVERLAY_PLANE">
            <summary>
                The layer is the overlay plane.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_UNDERLAY_PLANE">
            <summary>
                The layer is the underlay plane.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_DOUBLEBUFFER">
            <summary>
                <para>
                    The buffer is double-buffered.  This flag and <see cref="F:Tao.Platform.Windows.Gdi.PFD_SUPPORT_GDI"/>
                    are mutually exclusive in the current generic implementation.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_STEREO">
            <summary>
                <para>
                    The buffer is stereoscopic.  This flag is not supported in the current
                    generic implementation.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_DRAW_TO_WINDOW">
            <summary>
                <para>
                    The buffer can draw to a window or device surface.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_DRAW_TO_BITMAP">
            <summary>
                <para>
                    The buffer can draw to a memory bitmap.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_SUPPORT_GDI">
            <summary>
                <para>
                    The buffer supports GDI drawing.  This flag and
                    <see cref="F:Tao.Platform.Windows.Gdi.PFD_DOUBLEBUFFER"/> are mutually exclusive in the current generic
                    implementation.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_SUPPORT_OPENGL">
            <summary>
                <para>
                    The buffer supports OpenGL drawing.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_GENERIC_FORMAT">
            <summary>
                <para>
                    The pixel format is supported by the GDI software implementation, which is
                    also known as the generic implementation.  If this bit is clear, the pixel
                    format is supported by a device driver or hardware.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_NEED_PALETTE">
            <summary>
                <para>
                    The buffer uses RGBA pixels on a palette-managed device.  A logical palette
                    is required to achieve the best results for this pixel type.  Colors in the
                    palette should be specified according to the values of the <b>cRedBits</b>,
                    <b>cRedShift</b>, <b>cGreenBits</b>, <b>cGreenShift</b>, <b>cBluebits</b>,
                    and <b>cBlueShift</b> members.  The palette should be created and realized in
                    the device context before calling <see cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/>.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_NEED_SYSTEM_PALETTE">
            <summary>
                <para>
                    Defined in the pixel format descriptors of hardware that supports one
                    hardware palette in 256-color mode only.  For such systems to use
                    hardware acceleration, the hardware palette must be in a fixed order
                    (for example, 3-3-2) when in RGBA mode or must match the logical palette
                    when in color-index mode.
                </para>
                <para>
                    When this flag is set, you must call <see cref="!:SetSystemPaletteUse"/> in
                    your program to force a one-to-one mapping of the logical palette and the
                    system palette.  If your OpenGL hardware supports multiple hardware palettes
                    and the device driver can allocate spare hardware palettes for OpenGL, this
                    flag is typically clear.
                </para>
                <para>
                    This flag is not set in the generic pixel formats.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_SWAP_EXCHANGE">
            <summary>
                <para>
                    Specifies the content of the back buffer in the double-buffered main color
                    plane following a buffer swap.  Swapping the color buffers causes the
                    exchange of the back buffer's content with the front buffer's content.
                    Following the swap, the back buffer's content contains the front buffer's
                    content before the swap. <b>PFD_SWAP_EXCHANGE</b> is a hint only and might
                    not be provided by a driver.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_SWAP_COPY">
            <summary>
                <para>
                    Specifies the content of the back buffer in the double-buffered main color
                    plane following a buffer swap.  Swapping the color buffers causes the content
                    of the back buffer to be copied to the front buffer.  The content of the back
                    buffer is not affected by the swap.  <b>PFD_SWAP_COPY</b> is a hint only and
                    might not be provided by a driver.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_SWAP_LAYER_BUFFERS">
            <summary>
                <para>
                    Indicates whether a device can swap individual layer planes with pixel
                    formats that include double-buffered overlay or underlay planes.
                    Otherwise all layer planes are swapped together as a group.  When this
                    flag is set, <see cref="M:Tao.Platform.Windows.Wgl.wglSwapLayerBuffers(System.IntPtr,System.Int32)"/> is supported.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_GENERIC_ACCELERATED">
            <summary>
                <para>
                    The pixel format is supported by a device driver that accelerates the generic
                    implementation.  If this flag is clear and the
                    <see cref="F:Tao.Platform.Windows.Gdi.PFD_GENERIC_FORMAT"/> flag is set, the pixel format is supported
                    by the generic implementation only.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_SUPPORT_DIRECTDRAW">
            <summary>
                <para>
                    The buffer supports DirectDraw drawing.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_DEPTH_DONTCARE">
            <summary>
                <para>
                    The requested pixel format can either have or not have a depth buffer.  To
                    select a pixel format without a depth buffer, you must specify this flag.
                    The requested pixel format can be with or without a depth buffer.  Otherwise,
                    only pixel formats with a depth buffer are considered.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_DOUBLEBUFFER_DONTCARE">
            <summary>
                <para>
                    The requested pixel format can be either single- or double-buffered.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_STEREO_DONTCARE">
            <summary>
                <para>
                    The requested pixel format can be either monoscopic or stereoscopic.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DM_BITSPERPEL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DM_PELSWIDTH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DM_PELSHEIGHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DM_DISPLAYFLAGS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DM_DISPLAYFREQUENCY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.OUT_TT_PRECIS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.CLIP_DEFAULT_PRECIS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEFAULT_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DRAFT_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PROOF_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.NONANTIALIASED_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.ANTIALIASED_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.CLEARTYPE_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.CLEARTYPE_NATURAL_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEFAULT_PITCH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.FIXED_PITCH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.VARIABLE_PITCH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.MONO_FONT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.ANSI_CHARSET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEFAULT_CHARSET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.SYMBOL_CHARSET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.SHIFTJIS_CHARSET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.FF_DONTCARE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.FW_BOLD">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.#ctor">
            <summary>
                Prevents instantiation.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi._SetPixelFormat(System.IntPtr,System.Int32,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.ChoosePixelFormat(System.IntPtr,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)">
            <summary>
            The <b>ChoosePixelFormat</b> function attempts to match an appropriate pixel format supported by a device context
            to a given pixel format specification.
            </summary>
            <param name="deviceContext">
            Specifies the device context that the function examines to determine the best match for the pixel format
            descriptor pointed to by <i>ppfd</i>.
            </param>
            <param name="pixelFormatDescriptor">
            <para>
            	Pointer to a <see cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/> structure that specifies the requested pixel format.
            	In this context, the members of the <b>PIXELFORMATDESCRIPTOR</b> structure that <i>ppfd</i>
            	points to are used as follows:
            </para>
            <para>
            	<b>nSize</b><br/>
            	Specifies the size of the <b>PIXELFORMATDESCRIPTOR</b> data structure. Set this member to
            	<c>sizeof(PIXELFORMATDESCRIPTOR)</c>.
            </para>
            <para>
            	<b>nVersion</b><br/>
            	Specifies the version number of the <b>PIXELFORMATDESCRIPTOR</b> data structure. Set this member to 1.
            </para>
            <para>
            	<b>dwFlags</b><br/>
            	A set of bit flags that specify properties of the pixel buffer. You can combine the following bit
            	flag constants by using bitwise-OR.<br/><br/>
            	If any of the following flags are set, the <b>ChoosePixelFormat</b> function attempts to match pixel
            	formats that also have that flag or flags set. Otherwise, <b>ChoosePixelFormat</b> ignores that flag
            	in the pixel formats:<br/><br/>
            	PFD_DRAW_TO_WINDOW<br/>
            	PFD_DRAW_TO_BITMAP<br/>
            	PFD_SUPPORT_GDI<br/>
            	PFD_SUPPORT_OPENGL<br/><br/>
            	If any of the following flags are set, <b>ChoosePixelFormat</b> attempts to match pixel formats that
            	also have that flag or flags set. Otherwise, it attempts to match pixel formats without that flag set:<br/><br/>
            	PFD_DOUBLEBUFFER<br/>
            	PFD_STEREO<br/><br/>
            	If the following flag is set, the function ignores the PFD_DOUBLEBUFFER flag in the pixel formats:<br/><br/>
            	PFD_DOUBLEBUFFER_DONTCARE<br/><br/>
            	If the following flag is set, the function ignores the PFD_STEREO flag in the pixel formats:<br/><br/>
            	PFD_STEREO_DONTCARE<br/>
            </para>
            <para>
            	<b>iPixelType</b><br/>
            	Specifies the type of pixel format for the function to consider:<br/><br/>
            	PFD_TYPE_RGBA<br/>
            	PFD_TYPE_COLORINDEX<br/>
            </para>
            <para>
            	<b>cColorBits</b><br/>
            	Zero or greater.
            </para>
            <para>
            	<b>cRedBits</b><br/>
            	Not used.
            </para>
            <para>
            	<b>cRedShift</b><br/>
            	Not used.
            </para>
            <para>
            	<b>cGreenBits</b><br/>
            	Not used.
            </para>
            <para>
            	<b>cGreenShift</b><br/>
            	Not used.
            </para>
            <para>
            	<b>cBlueBits</b><br/>
            	Not used.
            </para>
            <para>
            	<b>cBlueShift</b><br/>
            	Not used.
            </para>
            <para>
            	<b>cAlphaBits</b><br/>
            	Zero or greater.
            </para>
            <para>
            	<b>cAlphaShift</b><br/>
            	Not used.
            </para>
            <para>
            	<b>cAccumBits</b><br/>
            	Zero or greater.
            </para>
            <para>
            	<b>cAccumRedBits</b><br/>
            	Not used.
            </para>
            <para>
            	<b>cAccumGreenBits</b><br/>
            	Not used.
            </para>
            <para>
            	<b>cAccumBlueBits</b><br/>
            	Not used.
            </para>
            <para>
            	<b>cAccumAlphaBits</b><br/>
            	Not used.
            </para>
            <para>
            	<b>cDepthBits</b><br/>
            	Zero or greater.
            </para>
            <para>
            	<b>cStencilBits</b><br/>
            	Zero or greater.
            </para>
            <para>
            	<b>cAuxBuffers</b><br/>
            	Zero or greater.
            </para>
            <para>
            	<b>iLayerType</b><br/>
            	Specifies one of the following layer type values:<br/><br/>
            	PFD_MAIN_PLANE<br/>
            	PFD_OVERLAY_PLANE<br/>
            	PFD_UNDERLAY_PLANE<br/>
            </para>
            <para>
            	<b>bReserved</b><br/>
            	Not used.
            </para>
            <para>
            	<b>dwLayerMask</b><br/>
            	Not used.
            </para>
            <para>
            	<b>dwVisibleMask</b><br/>
            	Not used.
            </para>
            <para>
            	<b>dwDamageMask</b><br/>
            	Not used.
            </para>
            </param>
            <returns>
            	If the function succeeds, the return value is a pixel format index (one-based) that is the closest match
            	to the given pixel format descriptor.<br/><br/>
            	If the function fails, the return value is zero. To get extended error information,
            	call <see cref="!:Kernel.GetLastError"/>.
            </returns>
            <remarks>
            	You must ensure that the pixel format matched by the <b>ChoosePixelFormat</b> function satisfies your
            	requirements. For example, if you request a pixel format with a 24-bit RGB color buffer but the device
            	context offers only 8-bit RGB color buffers, the function returns a pixel format with an 8-bit RGB color
            	buffer.<br/><br/>
            	The following code sample shows how to use <b>ChoosePixelFormat</b> to match a specified pixel
            	format:<br/><br/>
            	<code>
            		HDC hdc;
            		int pixelFormat;
            		Gdi.PIXELFORMATDESCRIPTOR pfd;
                        		// size of this pfd
            		pfd.nSize = (ushort) sizeof(Gdi.PIXELFORMATDESCRIPTOR);
                        		// version number
            		pfd.nVersion = 1;
                        		// support window, support OpenGL, double buffered
            		pfd.dwFlags = Gdi.PFD_DRAW_TO_WINDOW | Gdi.PFD_SUPPORT_OPENGL | Gdi.PFD_DOUBLEBUFFER;
                        		// RGBA type
            		pfd.iPixelType = Gdi.PFD_TYPE_RGBA;
                        		// 24-bit color depth
            		pfd.cColorBits = 24;
                        		// color bits and shift bits ignored
            		pfd.cRedBits = 0;
            		pfd.cRedShift = 0;
            		pfd.cGreenBits = 0;
            		pfd.cGreenShift = 0;
            		pfd.cBlueBits = 0;
            		pfd.cBlueShift = 0;
            		pfd.cAlphaBits = 0;
            		pfd.cAlphaShift = 0;
                        		// no accumulation buffer, accum bits ignored
            		pfd.cAccumBits = 0;
            		pfd.cAccumRedBits = 0;
            		pfd.cAccumGreenBits = 0;
            		pfd.cAccumBlueBits = 0;
            		pfd.cAccumAlphaBits = 0;
                        		// no stencil buffer
            		pfd.cStencilBits = 0;
                        		// no auxiliary buffer
            		pfd.cAuxBuffers = 0;
                        		// main layer
            		pfd.iLayerType = Gdi.PFD_MAIN_PLANE;
                        		// reserved
            		pfd.bReserved = 0;
                        		// layer masks ignored
            		pfd.dwLayerMask = 0;
            		pfd.dwVisibleMask = 0;
            		pfd.dwDamageMask = 0;
                        		pixelFormat = Gdi.ChoosePixelFormat(hdc, &amp;pfd);
            	</code>
            </remarks>
            <seealso cref="!:DescribePixelFormat"/>
            <seealso cref="!:GetPixelFormat"/>
            <seealso cref="M:Tao.Platform.Windows.Gdi.SetPixelFormat(System.IntPtr,System.Int32,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/>
            <param name="deviceContext"></param>
            <param name="pixelFormatDescriptor"></param>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.SetPixelFormat(System.IntPtr,System.Int32,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)">
            <summary>
            The <b>SetPixelFormat</b> function sets the pixel format of the specified device context to the format
            specified by the <i>iPixelFormat</i> index.
            </summary>
            <param name="hdc">
            	Specifies the device context whose pixel format the function attempts to set.
            </param>
            <param name="iPixelFormat">
            	Index that identifies the pixel format to set. The various pixel formats supported by a device
            	context are identified by one-based indexes.
            </param>
            <param name="ppfd">
            	Pointer to a <see cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/> structure that contains the logical pixel
            	format specification. The system's metafile component uses this structure to record the logical
            	pixel format specification. The structure has no other effect upon the behavior of the
            	<b>SetPixelFormat</b> function.
            </param>
            <returns>
            	If the function succeeds, the return value is true.<br/><br/>
            	If the function fails, the return value is false. To get extended error information, call
            	<see cref="!:Kernel.GetLastError"/>.
            </returns>
            <remarks>
            	If <i>hdc</i> references a window, calling the <b>SetPixelFormat</b> function also changes the pixel format
            	of the window. Setting the pixel format of a window more than once can lead to significant complications
            	for the Window Manager and for multithread applications, so it is not allowed. An application can only set
            	the pixel format of a window one time. Once a window's pixel format is set, it cannot be changed.<br/><br/>
                        	You should select a pixel format in the device context before calling the <see cref="M:Tao.Platform.Windows.Wgl.wglCreateContext(System.IntPtr)"/>
            	function. The <b>wglCreateContext</b> function creates a rendering context for drawing on the device in the
            	selected pixel format of the device context.<br/><br/>
                        	An OpenGL window has its own pixel format. Because of this, only device contexts retrieved for the client
            	area of an OpenGL window are allowed to draw into the window. As a result, an OpenGL window should be created
            	with the WS_CLIPCHILDREN and WS_CLIPSIBLINGS styles. Additionally, the window class attribute should not
            	include the CS_PARENTDC style.<br/><br/>
                        	The following code example shows <b>SetPixelFormat</b> usage:<br/><br/>
                        	<code>
            		HDC hdc;
            		int pixelFormat;
            		Gdi.PIXELFORMATDESCRIPTOR pfd;
                        		// size of this pfd
            		pfd.nSize = (ushort) sizeof(Gdi.PIXELFORMATDESCRIPTOR);
                        		// version number
            		pfd.nVersion = 1;
                        		// support window, support OpenGL, double buffered
            		pfd.dwFlags = Gdi.PFD_DRAW_TO_WINDOW | Gdi.PFD_SUPPORT_OPENGL | Gdi.PFD_DOUBLEBUFFER;
                        		// RGBA type
            		pfd.iPixelType = Gdi.PFD_TYPE_RGBA;
                        		// 24-bit color depth
            		pfd.cColorBits = 24;
                        		// color bits and shift bits ignored
            		pfd.cRedBits = 0;
            		pfd.cRedShift = 0;
            		pfd.cGreenBits = 0;
            		pfd.cGreenShift = 0;
            		pfd.cBlueBits = 0;
            		pfd.cBlueShift = 0;
            		pfd.cAlphaBits = 0;
            		pfd.cAlphaShift = 0;
                        		// no accumulation buffer, accum bits ignored
            		pfd.cAccumBits = 0;
            		pfd.cAccumRedBits = 0;
            		pfd.cAccumGreenBits = 0;
            		pfd.cAccumBlueBits = 0;
            		pfd.cAccumAlphaBits = 0;
                        		// no stencil buffer
            		pfd.cStencilBits = 0;
                        		// no auxiliary buffer
            		pfd.cAuxBuffers = 0;
                        		// main layer
            		pfd.iLayerType = Gdi.PFD_MAIN_PLANE;
                        		// reserved
            		pfd.bReserved = 0;
                        		// layer masks ignored
            		pfd.dwLayerMask = 0;
            		pfd.dwVisibleMask = 0;
            		pfd.dwDamageMask = 0;
                        		pixelFormat = Gdi.ChoosePixelFormat(hdc, &amp;pfd);
            		
            		// make that the pixel format of the device context
            		Gdi.SetPixelFormat(hdc, pixelFormat, &amp;pfd);
            	</code>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Gdi.ChoosePixelFormat(System.IntPtr,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/>
            <seealso cref="!:DescribePixelFormat"/>
            <seealso cref="!:GetPixelFormat"/>
            <param name="deviceContext"></param>
            <param name="pixelFormat"></param>
            <param name="pixelFormatDescriptor"></param>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.SwapBuffers(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="deviceContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.SwapBuffersFast(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="deviceContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.CreateFont(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="height"></param>
            <param name="width"></param>
            <param name="escapement"></param>
            <param name="orientation"></param>
            <param name="weight"></param>
            <param name="italic"></param>
            <param name="underline"></param>
            <param name="strikeOut"></param>
            <param name="charSet"></param>
            <param name="outputPrecision"></param>
            <param name="clipPrecision"></param>
            <param name="quality"></param>
            <param name="pitchAndFamily"></param>
            <param name="typeFace"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.DeleteObject(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="objectHandle"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.SelectObject(System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="deviceContext"></param>
            <param name="objectHandle"></param>
            <returns></returns>
        </member>
        <member name="T:Tao.Platform.Windows.Gdi.DEVMODE">
            <summary>
                <para>
                    The <b>DEVMODE</b> data structure contains information about the
                    initialization and environment of a printer or a display device.
                </para>
            </summary>
            <remarks>
                <para>
                    A device driver's private data follows the public portion of the
                    <b>DEVMODE</b> structure.  The size of the public data can vary for different
                    versions of the structure.  The <i>dmSize</i> member specifies the number of
                    bytes of public data, and the <i>dmDriverExtra</i> member specifies the
                    number of bytes of private data.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.User.ChangeDisplaySettings(Tao.Platform.Windows.Gdi.DEVMODE@,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.User.EnumDisplaySettings(System.String,System.Int32,Tao.Platform.Windows.Gdi.DEVMODE@)"/>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDeviceName">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmSpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDriverVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDriverExtra">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmFields">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmOrientation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPaperSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPaperLength">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPaperWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmScale">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmCopies">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDefaultSource">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPrintQuality">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmColor">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDuplex">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmYResolution">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmTTOption">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmCollate">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmFormName">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmLogPixels">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmBitsPerPel">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsHeight">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFrequency">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmICMMethod">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmICMIntent">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmMediaType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDitherType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmReserved1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmReserved2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPanningWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPanningHeight">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT">
            <summary>
            The <b>GLYPHMETRICSFLOAT</b> structure contains information about the placement and orientation of a glyph in a
            character cell.
            </summary>
            <remarks>The values of <b>GLYPHMETRICSFLOAT</b> are specified as notional units.</remarks>
            <seealso cref="T:Tao.Platform.Windows.Gdi.POINTFLOAT"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglUseFontOutlines(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT[])"/>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT.gmfBlackBoxX">
            <summary>
            Specifies the width of the smallest rectangle (the glyph's black box) that completely encloses the glyph.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT.gmfBlackBoxY">
            <summary>
            Specifies the height of the smallest rectangle (the glyph's black box) that completely encloses the glyph.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT.gmfptGlyphOrigin">
            <summary>
            Specifies the x and y coordinates of the upper-left corner of the smallest rectangle that completely encloses the glyph.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT.gmfCellIncX">
            <summary>
            Specifies the horizontal distance from the origin of the current character cell to the origin of the next character cell.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT.gmfCellIncY">
            <summary>
            Specifies the vertical distance from the origin of the current character cell to the origin of the next character cell.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR">
            <summary>
                The <b>PIXELFORMATDESCRIPTOR</b> structure describes the pixel format of a drawing surface.
            </summary>
            <remarks>
                Please notice carefully, as documented in the members, that certain pixel format properties are not supported
                in the current generic implementation. The generic implementation is the Microsoft GDI software
                implementation of OpenGL. Hardware manufacturers may enhance parts of OpenGL, and may support some
                pixel format properties not supported by the generic implementation.
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Gdi.ChoosePixelFormat(System.IntPtr,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/>
            <seealso cref="!:DescribePixelFormat"/>
            <seealso cref="!:GetPixelFormat"/>
            <seealso cref="M:Tao.Platform.Windows.Gdi.SetPixelFormat(System.IntPtr,System.Int32,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.nSize">
            <summary>
            Specifies the size of this data structure. This value should be set to <c>sizeof(PIXELFORMATDESCRIPTOR)</c>.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.nVersion">
            <summary>
            Specifies the version of this data structure. This value should be set to 1.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.dwFlags">
            <summary>
            A set of bit flags that specify properties of the pixel buffer. The properties are generally not mutually exclusive;
            you can set any combination of bit flags, with the exceptions noted.
            </summary>
            <remarks>
                <para>The following bit flag constants are defined:</para>
                <list type="table">
            		<listheader>
            			<term>Value</term>
            			<description>Meaning</description>
            		</listheader>
            		<item>
            			<term>PFD_DRAW_TO_WINDOW</term>
            			<description>The buffer can draw to a window or device surface.</description>
            		</item>
            		<item>
            			<term>PFD_DRAW_TO_BITMAP</term>
            			<description>The buffer can draw to a memory bitmap.</description>
            		</item>
            		<item>
            			<term>PFD_SUPPORT_GDI</term>
            			<description>
            				The buffer supports GDI drawing. This flag and PFD_DOUBLEBUFFER are mutually exclusive
            				in the current generic implementation.
            			</description>
            		</item>
            		<item>
            			<term>PFD_SUPPORT_OPENGL</term>
            			<description>The buffer supports OpenGL drawing.</description>
            		</item>
            		<item>
            			<term>PFD_GENERIC_ACCELERATED</term>
            			<description>
            				The pixel format is supported by a device driver that accelerates the generic implementation.
            				If this flag is clear and the PFD_GENERIC_FORMAT flag is set, the pixel format is supported by
            				the generic implementation only.
            			</description>
            		</item>
            		<item>
            			<term>PFD_GENERIC_FORMAT</term>
            			<description>
            				The pixel format is supported by the GDI software implementation, which is also known as the
            				generic implementation. If this bit is clear, the pixel format is supported by a device
            				driver or hardware.
            			</description>
            		</item>
            		<item>
            			<term>PFD_NEED_PALETTE</term>
            			<description>
            				The buffer uses RGBA pixels on a palette-managed device. A logical palette is required to achieve
            				the best results for this pixel type. Colors in the palette should be specified according to the
            				values of the <b>cRedBits</b>, <b>cRedShift</b>, <b>cGreenBits</b>, <b>cGreenShift</b>,
            				<b>cBluebits</b>, and <b>cBlueShift</b> members. The palette should be created and realized in
            				the device context before calling <see cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/>.
            			</description>
            		</item>
            		<item>
            			<term>PFD_NEED_SYSTEM_PALETTE</term>
            			<description>
            				Defined in the pixel format descriptors of hardware that supports one hardware palette in
            				256-color mode only. For such systems to use hardware acceleration, the hardware palette must be in
            				a fixed order (for example, 3-3-2) when in RGBA mode or must match the logical palette when in
            				color-index mode.
            				
            				When this flag is set, you must call SetSystemPaletteUse in your program to force a one-to-one
            				mapping of the logical palette and the system palette. If your OpenGL hardware supports multiple
            				hardware palettes and the device driver can allocate spare hardware palettes for OpenGL, this
            				flag is typically clear.
            				
            				This flag is not set in the generic pixel formats.
            			</description>
            		</item>
            		<item>
            			<term>PFD_DOUBLEBUFFER</term>
            			<description>
            				The buffer is double-buffered. This flag and PFD_SUPPORT_GDI are mutually exclusive in the
            				current generic implementation.
            			</description>
            		</item>
            		<item>
            			<term>PFD_STEREO</term>
            			<description>
            				The buffer is stereoscopic. This flag is not supported in the current generic implementation.
            			</description>
            		</item>
            		<item>
            			<term>PFD_SWAP_LAYER_BUFFERS</term>
            			<description>
            				Indicates whether a device can swap individual layer planes with pixel formats that include
            				double-buffered overlay or underlay planes. Otherwise all layer planes are swapped together
            				as a group. When this flag is set, <b>wglSwapLayerBuffers</b> is supported.
            			</description>
            		</item>
            	</list>
            	<para>You can specify the following bit flags when calling <see cref="M:Tao.Platform.Windows.Gdi.ChoosePixelFormat(System.IntPtr,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/>.</para>
            	<list type="table">
            		<listheader>
            			<term>Value</term>
            			<description>Meaning</description>
            		</listheader>
            		<item>
            			<term>PFD_DEPTH_DONTCARE</term>
            			<description>
            				The requested pixel format can either have or not have a depth buffer. To select
            				a pixel format without a depth buffer, you must specify this flag. The requested pixel format
            				can be with or without a depth buffer. Otherwise, only pixel formats with a depth buffer
            				are considered.
            			</description>
            		</item>
            		<item>
            			<term>PFD_DOUBLEBUFFER_DONTCARE</term>
            			<description>The requested pixel format can be either single- or double-buffered.</description>
            		</item>
            		<item>
            			<term>PFD_STEREO_DONTCARE</term>
            			<description>The requested pixel format can be either monoscopic or stereoscopic.</description>
            		</item>
            	</list>
            	<para>
            		With the <b>glAddSwapHintRectWIN</b> extension function, two new flags are included for the
            		<b>PIXELFORMATDESCRIPTOR</b> pixel format structure.
            	</para>
            	<list type="table">
            		<listheader>
            			<term>Value</term>
            			<description>Meaning</description>
            		</listheader>
            		<item>
            			<term>PFD_SWAP_COPY</term>
            			<description>
            				Specifies the content of the back buffer in the double-buffered main color plane following
            				a buffer swap. Swapping the color buffers causes the content of the back buffer to be copied
            				to the front buffer. The content of the back buffer is not affected by the swap. PFD_SWAP_COPY
            				is a hint only and might not be provided by a driver.
            			</description>
            		</item>
            		<item>
            			<term>PFD_SWAP_EXCHANGE</term>
            			<description>
            				Specifies the content of the back buffer in the double-buffered main color plane following a
            				buffer swap. Swapping the color buffers causes the exchange of the back buffer's content
            				with the front buffer's content. Following the swap, the back buffer's content contains the
            				front buffer's content before the swap. PFD_SWAP_EXCHANGE is a hint only and might not be
            				provided by a driver.
            			</description>
            		</item>
            	</list>
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.iPixelType">
            <summary>
            Specifies the type of pixel data. The following types are defined.
            </summary>
            <remarks>
            	<list type="table">
            		<listheader>
            			<term>Value</term>
            			<description>Meaning</description>
            		</listheader>
            		<item>
            			<term>PFD_TYPE_RGBA</term>
            			<description>
            				RGBA pixels. Each pixel has four components in this order: red, green, blue, and alpha.
            			</description>
            		</item>
            		<item>
            			<term>PFD_TYPE_COLORINDEX</term>
            			<description>Color-index pixels. Each pixel uses a color-index value.</description>
            		</item>
            	</list>
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cColorBits">
            <summary>
            Specifies the number of color bitplanes in each color buffer. For RGBA pixel types, it is the size
            of the color buffer, excluding the alpha bitplanes. For color-index pixels, it is the size of the
            color-index buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cRedBits">
            <summary>
            Specifies the number of red bitplanes in each RGBA color buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cRedShift">
            <summary>
            Specifies the shift count for red bitplanes in each RGBA color buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cGreenBits">
            <summary>
            Specifies the number of green bitplanes in each RGBA color buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cGreenShift">
            <summary>
            Specifies the shift count for green bitplanes in each RGBA color buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cBlueBits">
            <summary>
            Specifies the number of blue bitplanes in each RGBA color buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cBlueShift">
            <summary>
            Specifies the shift count for blue bitplanes in each RGBA color buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAlphaBits">
            <summary>
            Specifies the number of alpha bitplanes in each RGBA color buffer. Alpha bitplanes are not supported.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAlphaShift">
            <summary>
            Specifies the shift count for alpha bitplanes in each RGBA color buffer. Alpha bitplanes are not supported.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAccumBits">
            <summary>
            Specifies the total number of bitplanes in the accumulation buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAccumRedBits">
            <summary>
            Specifies the number of red bitplanes in the accumulation buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAccumGreenBits">
            <summary>
            Specifies the number of green bitplanes in the accumulation buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAccumBlueBits">
            <summary>
            Specifies the number of blue bitplanes in the accumulation buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAccumAlphaBits">
            <summary>
            Specifies the number of alpha bitplanes in the accumulation buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cDepthBits">
            <summary>
            Specifies the depth of the depth (z-axis) buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cStencilBits">
            <summary>
            Specifies the depth of the stencil buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAuxBuffers">
            <summary>
            Specifies the number of auxiliary buffers. Auxiliary buffers are not supported.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.iLayerType">
            <summary>
            Ignored. Earlier implementations of OpenGL used this member, but it is no longer used.
            </summary>
            <remarks>Specifies the type of layer.</remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.bReserved">
            <summary>
            Specifies the number of overlay and underlay planes. Bits 0 through 3 specify up to 15 overlay planes and
            bits 4 through 7 specify up to 15 underlay planes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.dwLayerMask">
            <summary>
            Ignored. Earlier implementations of OpenGL used this member, but it is no longer used.
            </summary>
            <remarks>
            	Specifies the layer mask. The layer mask is used in conjunction with the visible mask to determine
            	if one layer overlays another.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.dwVisibleMask">
            <summary>
            Specifies the transparent color or index of an underlay plane. When the pixel type is RGBA, <b>dwVisibleMask</b>
            is a transparent RGB color value. When the pixel type is color index, it is a transparent index value.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.dwDamageMask">
            <summary>
            Ignored. Earlier implementations of OpenGL used this member, but it is no longer used.
            </summary>
            <remarks>
            	Specifies whether more than one pixel format shares the same frame buffer. If the result of the bitwise
            	AND of the damage masks between two pixel formats is nonzero, then they share the same buffers.
            </remarks>
        </member>
        <member name="T:Tao.Platform.Windows.Gdi.POINTFLOAT">
            <summary>
            The <b>POINTFLOAT</b> structure contains the x and y coordinates of a point.
            </summary>
            <seealso cref="T:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT"/>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.POINTFLOAT.X">
            <summary>
            Specifies the horizontal (x) coordinate of a point.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.POINTFLOAT.Y">
            <summary>
            Specifies the vertical (y) coordinate of a point.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.IlasmAttribute">
            <summary>
                Injects supplied MSIL into the method's body.
            </summary>
            <remarks>
                This is a hack as the C# compiler does not allow inline MSIL.  This is extracted and
                the appropriate MSIL injected by the PostProcessTao utility.
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.IlasmAttribute.#ctor">
            <summary>
                Prevent instantiation without providing MSIL.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.IlasmAttribute.#ctor(System.String)">
            <summary>
                Injects the supplied MSIL into the tagged method's body.
            </summary>
            <param name="msil">
                The MSIL to inject.
            </param>
        </member>
        <member name="T:Tao.Platform.Windows.Kernel">
            <summary>
                Kernel binding for .NET, implementing Windows-specific kernel functionality.
            </summary>
            <remarks>
                Binds functions and definitions in kernel32.dll.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.KERNEL_NATIVE_LIBRARY">
            <summary>
                Specifies Kernel32's native library archive.
            </summary>
            <remarks>
                Specifies kernel32.dll for Windows.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.StdCall"/>.
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.#ctor">
            <summary>
                Prevents instantiation.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.Beep(System.Int32,System.Int32)">
            <summary>
                The <b>Beep</b> function generates simple tones on the speaker.  The function is
                synchronous; it does not return control to its caller until the sound finishes.
            </summary>
            <param name="frequency">
                <para>
                    Frequency of the sound, in hertz.  This parameter must be in the range
                    37 through 32,767 (0x25 through 0x7FFF).
                </para>
                <para>
                    <b>Windows 95/98/Me:</b>  The <b>Beep</b> function ignores this parameter.
                </para>
            </param>
            <param name="duration">
                <para>
                    Duration of the sound, in milliseconds.
                </para>
                <para>
                    <b>Windows 95/98/Me:</b>  The <b>Beep</b> function ignores this parameter.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    <b>Terminal Services:</b>  The beep is redirected to the client.
                </para>
                <para>
                    <b>Windows 95/98/Me:</b>  On computers with a sound card, the function
                    plays the default sound event.  On computers without a sound card, the
                    function plays the standard system beep.
                </para>
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.FreeLibrary(System.IntPtr)">
            <summary>
                The <b>FreeLibrary</b> function decrements the reference count of the loaded
                dynamic-link library (DLL).  When the reference count reaches zero, the module
                is unmapped from the address space of the calling process and the handle is no
                longer valid.
            </summary>
            <param name="moduleHandle">
                Handle to the loaded DLL module.  The <see cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/> or
                <see cref="M:Tao.Platform.Windows.Kernel.GetModuleHandle(System.String)"/> function returns this handle.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    Each process maintains a reference count for each loaded library module.  This
                    reference count is incremented each time <see cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/> is called
                    and is decremented each time <b>FreeLibrary</b> is called.  A DLL module
                    loaded at process initialization due to load-time dynamic linking has a
                    reference count of one.  This count is incremented if the same module is
                    loaded by a call to <see cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/>.
                </para>
                <para>
                    Before unmapping a library module, the system enables the DLL to detach from
                    the process by calling the DLL's <b>DllMain</b> function, if it has one, with
                    the DLL_PROCESS_DETACH value.  Doing so gives the DLL an opportunity to clean
                    up resources allocated on behalf of the current process.  After the
                    entry-point function returns, the library module is removed from the address
                    space of the current process.
                </para>
                <para>
                    It is not safe to call <b>FreeLibrary</b> from <b>DllMain</b>.  For more
                    information, see the Remarks section in <b>DllMain</b>.
                </para>
                <para>
                    Calling <b>FreeLibrary</b> does not affect other processes using the same
                    library module.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetModuleHandle(System.String)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetDllDirectory(System.Int32,System.Text.StringBuilder)">
            <summary>
                The <b>GetDllDirectory</b> function retrieves the application-specific portion of
                the search path used to locate DLLs for the application.
            </summary>
            <param name="bufferLength">
                Size of the output buffer, in characters.
            </param>
            <param name="buffer">
                Pointer to a buffer that receives the application-specific portion of the search path.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the length of the string copied
                    to <i>buffer</i>, in characters, not including the terminating null character.
                    If the return value is greater than <i>bufferLength</i>, it specifies the size
                    of the buffer required for the path.
                </para>
                <para>
                    If the function fails, the return value is zero.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <seealso cref="M:Tao.Platform.Windows.Kernel.SetDllDirectory(System.String)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetModuleFileName(System.IntPtr,System.Text.StringBuilder,System.Int32)">
            <summary>
                <para>
                    The <b>GetModuleFileName</b> function retrieves the fully qualified path for
                    the specified module.
                </para>
                <para>
                    To specify the process that contains the module, use the
                    <b>GetModuleFileNameEx</b> function.
                </para>
            </summary>
            <param name="module">
                Handle to the module whose path is being requested.  If this parameter is NULL,
                <b>GetModuleFileName</b> retrieves the path for the current module.
            </param>
            <param name="fileName">
                <para>
                    Pointer to a buffer that receives a null-terminated string that specifies the
                    fully-qualified path of the module.  If the length of the path exceeds the
                    size specified by the <i>size</i> parameter, the function succeeds and the
                    string is truncated to <i>size</i> characters and null terminated.
                </para>
                <para>
                    The path can have the prefix "\\?\", depending on how the module was loaded.
                </para>
            </param>
            <param name="size">
                Size of the <i>filename</i> buffer, in TCHARs.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the length of the string copied
                    to the buffer, in TCHARs.  If the buffer is too small to hold the module name,
                    the string is truncated to <i>size</i>, and the function returns <i>size</i>.
                </para>
                <para>
                    If the function fails, the return value is zero.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    If a DLL is loaded in two processes, its file name in one process may differ
                    in case from its file name in the other process.
                </para>
                <para>
                    For the ANSI version of the function, the number of TCHARs is the number of
                    bytes; for the Unicode version, it is the number of characters.
                </para>
                <para>
                    <b>Windows Me/98/95:</b>  This function retrieves long file names when an
                    application's version number is greater than or equal to 4.00 and the long
                    file name is available.  Otherwise, it returns only 8.3 format file names.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetModuleHandle(System.String)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetModuleHandle(System.String)">
            <summary>
                <para>
                    The <b>GetModuleHandle</b> function retrieves a module handle for the
                    specified module if the file has been mapped into the address space of the
                    calling process.
                </para>
                <para>
                    To avoid the race conditions described in the Remarks section, use the
                    <b>GetModuleHandleEx</b> function.
                </para>
            </summary>
            <param name="moduleName">
                <para>
                    Pointer to a null-terminated string that contains the name of the module
                    (either a .dll or .exe file).  If the file name extension is omitted, the
                    default library extension .dll is appended.  The file name string can include
                    a trailing point character (.) to indicate that the module name has no
                    extension.  The string does not have to specify a path.  When specifying a
                    path, be sure to use backslashes (\), not forward slashes (/).  The name is
                    compared (case independently) to the names of modules currently mapped into
                    the address space of the calling process.
                </para>
                <para>
                    If this parameter is NULL, <b>GetModuleHandle</b> returns a handle to the
                    file used to create the calling process.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is a handle to the specified module
                    (IntPtr).
                </para>
                <para>
                    If the function fails, the return value is NULL (IntPtr.Zero).  To get
                    extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The returned handle is not global or inheritable.  It cannot be duplicated
                    or used by another process.
                </para>
                <para>
                    The <b>GetModuleHandle</b> function returns a handle to a mapped module
                    without incrementing its reference count.  Therefore, use care when passing
                    the handle to the <see cref="M:Tao.Platform.Windows.Kernel.FreeLibrary(System.IntPtr)"/> function, because doing so can
                    cause a DLL module to be unmapped prematurely.
                </para>
                <para>
                    This function must be used carefully in a multithreaded application.  There
                    is no guarantee that the module handle remains valid between the time this
                    function returns the handle and the time it is used.  For example, a thread
                    retrieves a module handle, but before it uses the handle, a second thread
                    frees the module.  If the system loads another module, it could reuse the
                    module handle that was recently freed.  Therefore, first thread would have
                    a handle to a module different than the one intended.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.FreeLibrary(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetModuleFileName(System.IntPtr,System.Text.StringBuilder,System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetProcAddress(System.IntPtr,System.String)">
            <summary>
                The <b>GetProcAddress</b> function retrieves the address of an exported function
                or variable from the specified dynamic-link library (DLL).
            </summary>
            <param name="module">
                Handle to the DLL module that contains the function or variable.  The
                <see cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/> or <see cref="M:Tao.Platform.Windows.Kernel.GetModuleHandle(System.String)"/> function returns
                this handle.
            </param>
            <param name="processName">
                Pointer to a null-terminated string that specifies the function or variable name,
                or the function's ordinal value.  If this parameter is an ordinal value, it must
                be in the low-order word; the high-order word must be zero.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the address of the exported
                    function or variable.
                </para>
                <para>
                    If the function fails, the return value is NULL (IntPtr.Zero).  To get
                    extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The spelling and case of a function name pointed to by <i>processName</i> must
                    be identical to that in the EXPORTS statement of the source DLL's
                    module-definition (.def) file.  The exported names of functions may differ
                    from the names you use when calling these functions in your code.  This
                    difference is hidden by macros used in the SDK header files.
                </para>
                <para>
                    The <i>processName</i> parameter can identify the DLL function by specifying
                    an ordinal value associated with the function in the EXPORTS statement.
                    <b>GetProcAddress</b> verifies that the specified ordinal is in the range 1
                    through the highest ordinal value exported in the .def file.  The function
                    then uses the ordinal as an index to read the function's address from a
                    function table.  If the .def file does not number the functions consecutively
                    from 1 to N (where N is the number of exported functions), an error can occur
                    where <b>GetProcAddress</b> returns an invalid, non-NULL address, even though
                    there is no function with the specified ordinal.
                </para>
                <para>
                    In cases where the function may not exist, the function should be specified by
                    name rather than by ordinal value.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.FreeLibrary(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetModuleHandle(System.String)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetProcessWorkingSetSize(System.IntPtr,System.Int32@,System.Int32@)">
            <summary>
                The <b>GetProcessWorkingSetSize</b> function retrieves the minimum and maximum
                working set sizes of the specified process.
            </summary>
            <param name="process">
                Handle to the process whose working set sizes will be obtained.  The handle must
                have the PROCESS_QUERY_INFORMATION access right.
            </param>
            <param name="minimumWorkingSetSize">
                Pointer to a variable that receives the minimum working set size of the specified
                process, in bytes.  The virtual memory manager attempts to keep at least this much
                memory resident in the process whenever the process is active.
            </param>
            <param name="maximumWorkingSetSize">
                Pointer to a variable that receives the maximum working set size of the specified
                process, in bytes.  The virtual memory manager attempts to keep no more than this
                much memory resident in the process whenever the process is active when memory is
                in short supply.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                The "working set" of a process is the set of memory pages currently visible to
                the process in physical RAM memory.  These pages are resident and available for
                an application to use without triggering a page fault.  The minimum and maximum
                working set sizes affect the virtual memory paging behavior of a process.
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.SetProcessWorkingSetSize(System.IntPtr,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)">
            <summary>
                <para>
                    The <b>GetSystemDirectory</b> function retrieves the path of the system
                    directory.  The system directory contains system such files such as
                    dynamic-link libraries, drivers, and font files.
                </para>
                <para>
                    This function is provided primarily for compatibility.  Applications should
                    store code in the Program Files folder and persistent data in the Application
                    Data folder in the user's profile.
                </para>
            </summary>
            <param name="buffer">
                Pointer to the buffer to receive the null-terminated string containing the path.
                This path does not end with a backslash unless the system directory is the root
                directory.  For example, if the system directory is named Windows\System on drive
                C, the path of the system directory retrieved by this function is
                C:\Windows\System.
            </param>
            <param name="size">
                Maximum size of the buffer, in TCHARs.  This value should be set to at least
                MAX_PATH+1 to allow sufficient space for the path and the null terminator.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the length, in TCHARs, of the
                    string copied to the buffer, not including the terminating null character.  If
                    the length is greater than the size of the buffer, the return value is the
                    size of the buffer required to hold the path.
                </para>
                <para>
                    If the function fails, the return value is zero.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                Applications should not create files in the system directory.  If the user is
                running a shared version of the operating system, the application does not have
                write access to the system directory.
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetSystemInfo(Tao.Platform.Windows.Kernel.SYSTEM_INFO@)">
            <summary>
                <para>
                    The <b>GetSystemInfo</b> function returns information about the current
                    system.
                </para>
                <para>
                    To retrieve accurate information for a Win32-based application running on
                    WOW64, call the <b>GetNativeSystemInfo</b> function.
                </para>
            </summary>
            <param name="systemInfo">
                Pointer to a <see cref="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO"/> structure that receives the information.
            </param>
            <seealso cref="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetSystemWindowsDirectory(System.Text.StringBuilder,System.Int32)">
            <summary>
                The <b>GetSystemWindowsDirectory</b> function retrieves the path of the shared
                Windows directory on a multi-user system.
            </summary>
            <param name="buffer">
                Pointer to the buffer to receive a null-terminated string containing the path.
                This path does not end with a backslash unless the Windows directory is the root
                directory.  For example, if the Windows directory is named Windows on drive C,
                the path of the Windows directory retrieved by this function is C:\Windows.  If
                the system was installed in the root directory of drive C, the path retrieved
                is C:\.
            </param>
            <param name="size">
                Maximum size of the buffer specified by the <i>buffer</i> parameter, in TCHARs.
                This value should be set to at least MAX_PATH+1 to allow sufficient space for the
                path and the null-terminating character.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the length of the string copied
                    to the buffer, in TCHARs, not including the terminating null character.
                </para>
                <para>
                    If the length is greater than the size of the buffer, the return value is the
                    size of the buffer required to hold the path.
                </para>
                <para>
                    If the function fails, the return value is zero.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    On a system that is running Terminal Server, each user has a unique Windows
                    directory.  The system Windows directory is shared by all users, so it is the
                    directory where an application should store initialization and help files that
                    apply to all users.
                </para>
                <para>
                    With Terminal Services, the <b>GetSystemWindowsDirectory</b> function
                    retrieves the path of the system Windows directory, while the
                    <see cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/> function retrieves the path of a Windows
                    directory that is private for each user.  On a single-user system,
                    <b>GetSystemWindowsDirectory</b> is the same as
                    <see cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>.
                </para>
                <para>
                    <b>Windows NT 4.0 Terminal Server Edition:</b>  To retrieve the shared
                    Windows directory, call <see cref="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)"/> and trim the
                    "System32" element from the end of the returned path.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetTickCount">
            <summary>
                The <b>GetTickCount</b> function retrieves the number of milliseconds that have
                elapsed since the system was started.  It is limited to the resolution of the
                system timer.  To obtain the system timer resolution, use the
                <b>GetSystemTimeAdjustment</b> function.
            </summary>
            <returns>
                The return value is the number of milliseconds that have elapsed since the system
                was started.
            </returns>
            <remarks>
                <para>
                    The elapsed time is stored as a DWORD value.  Therefore, the time will wrap
                    around to zero if the system is run continuously for 49.7 days.
                </para>
                <para>
                    If you need a higher resolution timer, use a multimedia timer or a
                    high-resolution timer.
                </para>
                <para>
                    To obtain the time elapsed since the computer was started, retrieve the System
                    Up Time counter in the performance data in the registry key
                    HKEY_PERFORMANCE_DATA.  The value returned is an 8-byte value.
                </para>
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)">
            <summary>
                <para>
                    The <b>GetWindowsDirectory</b> function retrieves the path of the Windows
                    directory.  The Windows directory contains such files as applications,
                    initialization files, and help files.
                </para>
                <para>
                    This function is provided primarily for compatibility.  Applications should
                    store code in the Program Files folder and persistent data in the Application
                    Data folder in the user's profile.
                </para>
            </summary>
            <param name="buffer">
                Pointer to the buffer to receive the null-terminated string containing the path.
                This path does not end with a backslash unless the Windows directory is the root
                directory.  For example, if the Windows directory is named Windows on drive C, the
                path of the Windows directory retrieved by this function is C:\Windows.  If the
                system was installed in the root directory of drive C, the path retrieved is C:\.
            </param>
            <param name="size">
                Maximum size of the buffer specified by the <i>buffer</i> parameter, in TCHARs.
                This value should be set to MAX_PATH.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the length of the string copied
                    to the buffer, in TCHARs, not including the terminating null character.
                </para>
                <para>
                    If the length is greater than the size of the buffer, the return value is the
                    size of the buffer required to hold the path.
                </para>
                <para>
                    If the function fails, the return value is zero.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The Windows directory is the directory where an application should store
                    initialization and help files. If the user is running a shared version of the
                    system, the Windows directory is guaranteed to be private for each user.
                </para>
                <para>
                    If an application creates other files that it wants to store on a per-user
                    basis, it should place them in the directory specified by the HOMEPATH
                    environment variable.  This directory will be different for each user, if so
                    specified by an administrator, through the User Manager administrative tool.
                    HOMEPATH always specifies either the user's home directory, which is
                    guaranteed to be private for each user, or a default directory (for example,
                    C:\USERS\DEFAULT) where the user will have all access.
                </para>
                <para>
                    <b>Terminal Services:</b>  If the application is running in a Terminal
                    Services environment, each user has a unique Windows directory.  If an
                    application that is not Terminal-Services-aware calls this function, it
                    retrieves the path of the Windows directory on the client, not the Windows
                    directory on the server.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetSystemWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GlobalMemoryStatus(Tao.Platform.Windows.Kernel.MEMORYSTATUS@)">
            <summary>
                <para>
                    The <b>GlobalMemoryStatus</b> function obtains information about the system's
                    current usage of both physical and virtual memory.
                </para>
                <para>
                    To obtain information about the extended portion of the virtual address space,
                    or if your application may run on computers with more than 4 GB of main
                    memory, use the <b>GlobalMemoryStatusEx</b> function.
                </para>
            </summary>
            <param name="buffer">
                Pointer to a <see cref="T:Tao.Platform.Windows.Kernel.MEMORYSTATUS"/> structure.  The <b>GlobalMemoryStatus</b>
                function stores information about current memory availability into this structure.
            </param>
            <remarks>
                <para>
                    You can use the <b>GlobalMemoryStatus</b> function to determine how much
                    memory your application can allocate without severely impacting other
                    applications.
                </para>
                <para>
                    The information returned by the <b>GlobalMemoryStatus</b> function is
                    volatile.  There is no guarantee that two sequential calls to this function
                    will return the same information.
                </para>
                <para>
                    On computers with more than 4 GB of memory, the <b>GlobalMemoryStatus</b>
                    function can return incorrect information.  Windows 2000 and later report a
                    value of -1 to indicate an overflow.  Earlier versions of Windows NT report a
                    value that is the real amount of memory, modulo 4 GB.  For this reason, use
                    the <b>GlobalMemoryStatusEx</b> function instead.
                </para>
                <para>
                    On Intel x86 computers with more than 2 GB and less than 4 GB of memory, the
                    <b>GlobalMemoryStatus</b> function will always return 2 GB in the
                    <see cref="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.TotalPhys"/> member of the
                    <see cref="T:Tao.Platform.Windows.Kernel.MEMORYSTATUS"/> structure.  Similarly, if the total available
                    memory is between 2 and 4 GB, the <see cref="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.AvailPhys"/> member
                    of the <see cref="T:Tao.Platform.Windows.Kernel.MEMORYSTATUS"/> structure will be rounded down to 2 GB.  If
                    the executable is linked using the /LARGEADDRESSWARE linker option, then the
                    <b>GlobalMemoryStatus</b> function will return the correct amount of physical
                    memory in both members.
                </para>
            </remarks>
            <seealso cref="T:Tao.Platform.Windows.Kernel.MEMORYSTATUS"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.IsProcessorFeaturePresent(System.Int32)">
            <summary>
                The <b>IsProcessorFeaturePresent</b> function determines whether the specified
                processor feature is supported by the current computer.
            </summary>
            <param name="processorFeature">
                <para>
                    Processor feature to be tested.  This parameter can be one of the following
                    values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_3DNOW_INSTRUCTIONS_AVAILABLE"/></term>
                            <description>
                                The 3D-Now instruction set is available.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_COMPARE_EXCHANGE_DOUBLE"/></term>
                            <description>
                                The compare and exchange double operation is available (Pentium,
                                MIPS, and Alpha).
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_FLOATING_POINT_EMULATED"/></term>
                            <description>
                                <para>
                                    Floating-point operations are emulated using a software
                                    emulator.
                                </para>
                                <para>
                                    This function returns true if floating-point operations are
                                    emulated; otherwise, it returns false.
                                </para>
                                <para>
                                    <b>Windows NT 4.0:</b>  This function returns false if
                                    floating-point operations are emulated; otherwise, it returns
                                    true.  This behavior is a bug that is fixed in later versions.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_FLOATING_POINT_PRECISION_ERRATA"/></term>
                            <description>
                                <b>Pentium:</b>  In rare circumstances, a floating-point precision
                                error can occur.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_MMX_INSTRUCTIONS_AVAILABLE"/></term>
                            <description>
                                The MMX instruction set is available.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_PAE_ENABLED"/></term>
                            <description>
                                The processor is PAE-enabled.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_RDTSC_INSTRUCTION_AVAILABLE"/></term>
                            <description>
                                The RDTSC instruction is available.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_XMMI_INSTRUCTIONS_AVAILABLE"/></term>
                            <description>
                                The SSE instruction set is available.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_XMMI64_INSTRUCTIONS_AVAILABLE"/></term>
                            <description>
                                The SSE2 instruction set is available.
                            </description>
                        </item>
                    </list>
                </para>
            </param>
            <returns>
                <para>
                    If the feature is supported, the return value is true.
                </para>
                <para>
                    If the feature is not supported, the return value is false.
                </para>
            </returns>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)">
            <summary>
                The <b>LoadLibrary</b> function maps the specified executable module into the
                address space of the calling process.
            </summary>
            <param name="fileName">
                <para>
                    Pointer to a null-terminated string that names the executable module (either
                    a .dll or .exe file).  The name specified is the file name of the module and
                    is not related to the name stored in the library module itself, as specified
                    by the LIBRARY keyword in the module-definition (.def) file.
                </para>
                <para>
                    If the string specifies a path but the file does not exist in the specified
                    directory, the function fails.  When specifying a path, be sure to use
                    backslashes (\), not forward slashes (/).
                </para>
                <para>
                    If the string does not specify a path, the function uses a standard search
                    strategy to find the file.  See the Remarks for more information.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is a handle to the module (IntPtr).
                </para>
                <para>
                    If the function fails, the return value is NULL (IntPtr.Zero).  To get
                    extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
                <para>
                    <b>Windows Me/98/95:</b>  If you are using <b>LoadLibrary</b> to load a module
                    that contains a resource whose numeric identifier is greater than 0x7FFF,
                    <b>LoadLibrary</b> fails.  If you are attempting to load a 16-bit DLL directly
                    from 32-bit code, <b>LoadLibrary</b> fails.  If you are attempting to load a
                    DLL whose subsystem version is greater than 4.0, <b>LoadLibrary</b> fails.  If
                    your <b>DllMain</b> function tries to call the Unicode version of a function,
                    <b>LoadLibrary</b> fails.
                </para>
            </returns>
            <remarks>
                <para>
                    <b>LoadLibrary</b> can be used to map a DLL module and return a handle that
                    can be used in <see cref="M:Tao.Platform.Windows.Kernel.GetProcAddress(System.IntPtr,System.String)"/> to get the address of a DLL
                    function.  <b>LoadLibrary</b> can also be used to map other executable
                    modules.  For example, the function can specify an .exe file to get a
                    handle that can be used in <b>FindResource</b> or <b>LoadResource</b>.
                    However, do not use <b>LoadLibrary</b> to run an .exe file, use the
                    <b>CreateProcess</b> function.
                </para>
                <para>
                    If the module is a DLL not already mapped for the calling process, the system
                    calls the DLL's <b>DllMain</b> function with the DLL_PROCESS_ATTACH value.  If
                    the DLL's entry-point function does not return TRUE, <b>LoadLibrary</b> fails
                    and returns NULL.  (The system immediately calls your entry-point function
                    with DLL_PROCESS_DETACH and unloads the DLL.)
                </para>
                <para>
                    It is not safe to call <b>LoadLibrary</b> from <b>DllMain</b>.  For more
                    information, see the Remarks section in <b>DllMain</b>.
                </para>
                <para>
                    Module handles are not global or inheritable.  A call to <b>LoadLibrary</b> by
                    one process does not produce a handle that another process can use  for
                    example, in calling <see cref="M:Tao.Platform.Windows.Kernel.GetProcAddress(System.IntPtr,System.String)"/>.  The other process must
                    make its own call to <b>LoadLibrary</b> for the module before calling
                    <see cref="M:Tao.Platform.Windows.Kernel.GetProcAddress(System.IntPtr,System.String)"/>.
                </para>
                <para>
                    If no file name extension is specified in the <i>fileName</i> parameter, the
                    default library extension .dll is appended.  However, the file name string
                    can include a trailing point character (.) to indicate that the module name
                    has no extension.  When no path is specified, the function searches for loaded
                    modules whose base name matches the base name of the module to be loaded.  If
                    the name matches, the load succeeds.  Otherwise, the function searches for the
                    file in the following sequence:
                </para>
                <para>
                    <list type="number">
                        <item>
                            <description>
                                The directory from which the application loaded.
                            </description>
                        </item>
                        <item>
                            <description>
                                The current directory.
                            </description>
                        </item>
                        <item>
                            <description>
                                The system directory.  Use the <see cref="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)"/>
                                function to get the path of this directory.
                            </description>
                        </item>
                        <item>
                            <description>
                                <para>
                                    The 16-bit system directory.  There is no function that
                                    obtains the path of this directory, but it is searched.
                                </para>
                                <para>
                                    <b>Windows Me/98/95:</b>  This directory does not exist.
                                </para>
                            </description>
                        </item>
                        <item>
                            <description>
                                The Windows directory.  Use the <see cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
                                function to get the path of this directory.
                            </description>
                        </item>
                        <item>
                            <description>
                                The directories that are listed in the PATH environment variable.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    <b>Windows Server 2003, Windows XP SP1:</b>  The default value of
                    HKLM\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode is 1
                    (current directory is searched after the system and Windows directories).
                </para>
                <para>
                    <b>Windows XP:</b>  If
                    HKLM\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode is 1,
                    the current directory is searched after the system and Windows directories,
                    but before the directories in the PATH environment variable.  The default
                    value is 0 (current directory is searched before the system and Windows
                    directories).
                </para>
                <para>
                    The first directory searched is the one directory containing the image file
                    used to create the calling process (for more information, see the
                    <b>CreateProcess</b> function).  Doing this allows private dynamic-link
                    library (DLL) files associated with a process to be found without adding the
                    process's installed directory to the PATH environment variable.
                </para>
                <para>
                    The search path can be altered using the <see cref="M:Tao.Platform.Windows.Kernel.SetDllDirectory(System.String)"/>
                    function.  This solution is recommended instead of using
                    <b>SetCurrentDirectory</b> or hard-coding the full path to the DLL.
                </para>
                <para>
                    If a path is specified and there is a redirection file for the application,
                    the function searches for the module in the application's directory.  If the
                    module exists in the application's directory, the <b>LoadLibrary</b> function
                    ignores the specified path and loads the module from the application's
                    directory.  If the module does not exist in the application's directory,
                    <b>LoadLibrary</b> loads the module from the specified directory.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.FreeLibrary(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetProcAddress(System.IntPtr,System.String)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.SetDllDirectory(System.String)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounter(System.Int64@)">
            <summary>
                The <b>QueryPerformanceCounter</b> function retrieves the current value of the
                high-resolution performance counter.
            </summary>
            <param name="performanceCount">
                Pointer to a variable that receives the current performance-counter value, in
                counts.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                On a multiprocessor machine, it should not matter which processor is called.
                However, you can get different results on different processors due to bugs in the
                BIOS or the HAL.  To specify processor affinity for a thread, use the
                <b>SetThreadAffinityMask</b> function.
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounterFast(System.Int64@)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceFrequency(System.Int64@)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounterFast(System.Int64@)">
            <summary>
                The <b>QueryPerformanceCounterFast</b> function retrieves the current value of the
                high-resolution performance counter.
            </summary>
            <param name="performanceCount">
                Pointer to a variable that receives the current performance-counter value, in
                counts.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.
                </para>
            </returns>
            <remarks>
                <para>
                    This version of <see cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounter(System.Int64@)"/> is slightly faster.  It
                    does not set the last Windows error.  Use with care.
                </para>
                <para>
                    On a multiprocessor machine, it should not matter which processor is called.
                    However, you can get different results on different processors due to bugs in
                    the BIOS or the HAL.  To specify processor affinity for a thread, use the
                    <b>SetThreadAffinityMask</b> function.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounter(System.Int64@)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceFrequency(System.Int64@)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.QueryPerformanceFrequency(System.Int64@)">
            <summary>
                The <b>QueryPerformanceFrequency</b> function retrieves the frequency of the
                high-resolution performance counter, if one exists.  The frequency cannot change
                while the system is running.
            </summary>
            <param name="frequency">
                Pointer to a variable that receives the current performance-counter frequency, in
                counts per second.  If the installed hardware does not support a high-resolution
                performance counter, this parameter can be zero.
            </param>
            <returns>
                <para>
                    If the installed hardware supports a high-resolution performance counter, the
                    return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.  For example, if
                    the installed hardware does not support a high-resolution performance counter,
                    the function fails.
                </para>
            </returns>
            <remarks>
                <b>Note</b>  The frequency of the high-resolution performance counter is not the
                processor speed.
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounter(System.Int64@)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.SetDllDirectory(System.String)">
            <summary>
                The <b>SetDllDirectory</b> function modifies the search path used to locate DLLs
                for the application.
            </summary>
            <param name="pathName">
                Pointer to a null-terminated string that specifies the directories to be added to
                the search path, separated by semicolons.  If this parameter is NULL, the default
                search path is used.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The <b>SetDllDirectory</b> function affects all subsequent calls to the
                    <see cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/> and <b>LoadLibraryEx</b> functions.  After calling
                    <b>SetDllDirectory</b>, the DLL search path is:
                </para>
                <para>
                    <list type="number">
                        <item>
                            <description>
                                The directory from which the application loaded.
                            </description>
                        </item>
                        <item>
                            <description>
                                The directory specified by the <i>pathName</i> parameter.
                            </description>
                        </item>
                        <item>
                            <description>
                                The system directory.  Use the <see cref="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)"/>
                                function to get the path of this directory.  The name of this
                                directory is System32.
                            </description>
                        </item>
                        <item>
                            <description>
                                The 16-bit system directory.  There is no function that obtains
                                the path of this directory, but it is searched.  The name of this
                                directory is System.
                            </description>
                        </item>
                        <item>
                            <description>
                                The Windows directory.  Use the <see cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
                                function to get the path of this directory.
                            </description>
                        </item>
                        <item>
                            <description>
                                The directories that are listed in the PATH environment variable.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    To revert to the default search path used by <see cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/> and
                    <b>LoadLibraryEx</b>, call <b>SetDllDirectory</b> with NULL.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetDllDirectory(System.Int32,System.Text.StringBuilder)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.SetProcessWorkingSetSize(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                The <b>SetProcessWorkingSetSize</b> function sets the minimum and maximum working
                set sizes for the specified process.
            </summary>
            <param name="process">
                <para>
                    Handle to the process whose working set sizes is to be set.
                </para>
                <para>
                    The handle must have the PROCESS_SET_QUOTA access right.
                </para>
            </param>
            <param name="minimumWorkingSetSize">
                <para>
                    Minimum working set size for the process, in bytes.  The virtual memory
                    manager attempts to keep at least this much memory resident in the
                    process whenever the process is active.
                </para>
                <para>
                    If both <i>minimumWorkingSetSize</i> and <i>maximumWorkingSetSize</i> have the
                    value -1, the function temporarily trims the working set of the specified
                    process to zero.  This essentially swaps the process out of physical RAM
                    memory.
                </para>
            </param>
            <param name="maximumWorkingSetSize">
                <para>
                    Maximum working set size for the process, in bytes.  The virtual memory
                    manager attempts to keep no more than this much memory resident in the
                    process whenever the process is active and memory is in short supply.
                </para>
                <para>
                    If both <i>minimumWorkingSetSize</i> and <i>maximumWorkingSetSize</i> have the
                    value -1, the function temporarily trims the working set of the specified
                    process to zero.  This essentially swaps the process out of physical RAM
                    memory.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The working set of a process is the set of memory pages currently visible to
                    the process in physical RAM memory.  These pages are resident and available
                    for an application to use without triggering a page fault.  The minimum and
                    maximum working set sizes affect the virtual memory paging behavior of a
                    process.
                </para>
                <para>
                    The working set of the specified process can be emptied by specifying the
                    value -1 for both the minimum and maximum working set sizes.
                </para>
                <para>
                    If the values of either <i>minimumWorkingSetSize</i> or
                    <i>maximumWorkingSetSize</i> are greater than the process' current working
                    set sizes, the specified process must have the SE_INC_BASE_PRIORITY_NAME
                    privilege.  Users in the Administrators and Power Users groups generally
                    have this privilege.
                </para>
                <para>
                    The operating system allocates working set sizes on a first-come,
                    first-served basis.  For example, if an application successfully sets 40
                    megabytes as its minimum working set size on a 64-megabyte system, and a
                    second application requests a 40-megabyte working set size, the operating
                    system denies the second application's request.
                </para>
                <para>
                    Using the <b>SetProcessWorkingSetSize</b> function to set an application's
                    minimum and maximum working set sizes does not guarantee that the requested
                    memory will be reserved, or that it will remain resident at all times.  When
                    the application is idle, or a low-memory situation causes a demand for memory,
                    the operating system can reduce the application's working set.  An application
                    can use the <b>VirtualLock</b> function to lock ranges of the application's
                    virtual address space in memory; however, that can potentially degrade the
                    performance of the system.
                </para>
                <para>
                    When you increase the working set size of an application, you are taking away
                    physical memory from the rest of the system.  This can degrade the performance
                    of other applications and the system as a whole.  It can also lead to failures
                    of operations that require physical memory to be present; for example,
                    creating processes, threads, and kernel pool.  Thus, you must use the
                    <b>SetProcessWorkingSetSize</b> function carefully.  You must always consider
                    the performance of the whole system when you are designing an application.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetProcessWorkingSetSize(System.IntPtr,System.Int32@,System.Int32@)"/>
        </member>
        <member name="T:Tao.Platform.Windows.Kernel.MEMORYSTATUS">
            <summary>
                <para>
                    The <b>MEMORYSTATUS</b> structure contains information about the current state
                    of both physical and virtual memory.
                </para>
                <para>
                    The <see cref="M:Tao.Platform.Windows.Kernel.GlobalMemoryStatus(Tao.Platform.Windows.Kernel.MEMORYSTATUS@)"/> function stores information in a
                    <b>MEMORYSTATUS</b> structure.
                </para>
            </summary>
            <remarks>
                <para>
                    <b>MEMORYSTATUS</b> reflects the state of memory at the time of the call.  It
                    reflects the size of the paging file at that time.  The operating system can
                    enlarge the paging file up to the maximum size set by the administrator.
                </para>
                <para>
                    On computers with more than 4 GB of memory, the <b>MEMORYSTATUS</b> structure
                    can return incorrect information.  Windows reports a value of -1 to indicate
                    an overflow, while Windows NT reports a value that is the real amount of
                    memory, modulo 4 GB.  If your application is at risk for this behavior, use
                    the <b>GlobalMemoryStatusEx</b> function instead of the
                    <see cref="M:Tao.Platform.Windows.Kernel.GlobalMemoryStatus(Tao.Platform.Windows.Kernel.MEMORYSTATUS@)"/> function.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GlobalMemoryStatus(Tao.Platform.Windows.Kernel.MEMORYSTATUS@)"/>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.Length">
            <summary>
                Size of the <b>MEMORYSTATUS</b> data structure, in bytes.  You do not need to
                set this member before calling the <see cref="M:Tao.Platform.Windows.Kernel.GlobalMemoryStatus(Tao.Platform.Windows.Kernel.MEMORYSTATUS@)"/> function;
                the function sets it.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.MemoryLoad">
            <summary>
                <para>
                    Approximate percentage of total physical memory that is in use.
                </para>
                <para>
                    <b>Windows NT:</b>  Percentage of approximately the last 1000 pages of
                    physical memory that is in use.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.TotalPhys">
            <summary>
                Total size of physical memory, in bytes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.AvailPhys">
            <summary>
                Size of physical memory available, in bytes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.TotalPageFile">
            <summary>
                Size of the committed memory limit, in bytes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.AvailPageFile">
            <summary>
                Size of available memory to commit, in bytes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.TotalVirtual">
            <summary>
                Total size of the user mode portion of the virtual address space of the
                calling process, in bytes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.AvailVirtual">
            <summary>
                Size of unreserved and uncommitted memory in the user mode portion of the
                virtual address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO">
            <summary>
                The <b>SYSTEM_INFO</b> structure contains information about the current computer
                system.  This includes the architecture and type of the processor, the number of
                processors in the system, the page size, and other such information.
            </summary>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetSystemInfo(Tao.Platform.Windows.Kernel.SYSTEM_INFO@)"/>
            <seealso cref="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO_UNION"/>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.SystemInfoUnion">
            <summary>
                Union for the OemId, ProcessorArchitecture, and Reserved fields of the
                SYSTEM_INFO structure.  See <see cref="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO_UNION"/>.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.PageSize">
            <summary>
                Page size and the granularity of page protection and commitment.  This is the
                page size used by the <b>VirtualAlloc</b> function.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.MinimumApplicationAddress">
            <summary>
                Pointer to the lowest memory address accessible to applications and
                dynamic-link libraries (DLLs).
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.MaximumApplicationAddress">
            <summary>
                Pointer to the highest memory address accessible to applications and DLLs.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.ActiveProcessorMask">
            <summary>
                Mask representing the set of processors configured into the system.  Bit 0 is
                processor 0; bit 31 is processor 31.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.NumberOfProcessors">
            <summary>
                Number of processors in the system.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.ProcessorType">
            <summary>
                <para>
                    An obsolete member that is retained for compatibility with Windows NT 3.5
                    and earlier.  Use the <i>SystemInfoUnion.ProcessorArchitecture</i>,
                    <i>ProcessorLevel</i>, and <i>ProcessorRevision</i> members to determine
                    the type of processor.
                </para>
                <para>
                    <b>Windows Me/98/95:</b>  Specifies the type of processor in the system.
                    This member is one of the following values:
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_386"/>
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_486"/>
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_PENTIUM"/>
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.AllocationGranularity">
            <summary>
                Granularity with which virtual memory is allocated.  For example, a
                <b>VirtualAlloc</b> request to allocate 1 byte will reserve an address space
                of <i>AllocationGranularity</i> bytes.  This value was hard coded as 64K in
                the past, but other hardware architectures may require different values.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.ProcessorLevel">
            <summary>
                <para>
                    System's architecture-dependent processor level.  It should be used only
                    for display purposes.  To determine the feature set of a processor, use
                    the <see cref="M:Tao.Platform.Windows.Kernel.IsProcessorFeaturePresent(System.Int32)"/> function.
                </para>
                <para>
                    If <i>SystemInfoUnion.ProcessorArchitecture</i> is
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_INTEL"/>, <i>ProcessorLevel</i>
                    is defined by the CPU vendor.
                </para>
                <para>
                    If <i>SystemInfoUnion.ProcessorArchitecture</i> is
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_IA64"/>, <i>ProcessorLevel</i> is
                    set to 1.
                </para>
                <para>
                    If <i>SystemInfoUnion.ProcessorArchitecture</i> is
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_MIPS"/>, <i>ProcessorLevel</i> is
                    of the form 00xx, where xx is an 8-bit implementation number (bits 8-15 of
                    the PRId register).  The member can be the following value:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>0004</term>
                            <description>MIPS R4000</description>
                        </item>
                    </list>
                </para>
                <para>
                    If <i>SystemInfoUnion.ProcessorArchitecture</i> is
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_ALPHA"/>, <i>ProcessorLevel</i>
                    is of the form xxxx, where xxxx is a 16-bit processor version number (the
                    low-order 16 bits of a version number from the firmware).  The member can
                    be one of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>21064</term>
                            <description>Alpha 21064</description>
                        </item>
                        <item>
                            <term>21066</term>
                            <description>Alpha 21066</description>
                        </item>
                        <item>
                            <term>21164</term>
                            <description>Alpha 21164</description>
                        </item>
                    </list>
                </para>
                <para>
                    If <i>SystemInfoUnion.ProcessorArchitecture</i> is
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_PPC"/>, <i>ProcessorLevel</i> is
                    of the form xxxx, where xxxx is a 16-bit processor version number (the
                    high-order 16 bits of the Processor Version Register).  The member can be
                    one of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>1</term>
                            <description>PPC 601</description>
                        </item>
                        <item>
                            <term>3</term>
                            <description>PPC 603</description>
                        </item>
                        <item>
                            <term>4</term>
                            <description>PPC 604</description>
                        </item>
                        <item>
                            <term>6</term>
                            <description>PPC 603+</description>
                        </item>
                        <item>
                            <term>9</term>
                            <description>PPC 604+</description>
                        </item>
                        <item>
                            <term>20</term>
                            <description>PPC 620</description>
                        </item>
                    </list>
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.ProcessorRevision">
            <summary>
                <para>
                    Architecture-dependent processor revision.  The following table shows how
                    the revision value is assembled for each type of processor architecture:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Processor</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>Intel 80386 or 80486</term>
                            <description>
                                <para>
                                    A value of the form xxyz.
                                </para>
                                <para>
                                    If xx is equal to 0xFF, y - 0xA is the model number, and
                                    z is the stepping identifier.  For example, an Intel
                                    80486-D0 system returns 0xFFD0.
                                </para>
                                <para>
                                    If xx is not equal to 0xFF, xx + 'A' is the stepping
                                    letter and yz is the minor stepping.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term>Intel Pentium, Cyrix, or NextGen 586</term>
                            <description>
                                <para>
                                    A value of the form xxyy, where xx is the model number and
                                    yy is the stepping.  Display this value of 0x0201 as
                                    follows:
                                </para>
                                <para>
                                    Model xx, Stepping yy.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term>MIPS</term>
                            <description>
                                A value of the form 00xx, where xx is the 8-bit revision
                                number of the processor (the low-order 8 bits of the
                                PRId register).
                            </description>
                        </item>
                        <item>
                            <term>ALPHA</term>
                            <description>
                                <para>
                                    A value of the form xxyy, where xxyy is the low-order 16
                                    bits of the processor revision number from the firmware.
                                    Display this value as follows:
                                </para>
                                <para>
                                    Model A+xx, Pass yy.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term>PPC</term>
                            <description>
                                <para>
                                    A value of the form xxyy, where xxyy is the low-order 16
                                    bits of the processor version register.  Display this
                                    value as follows:
                                </para>
                                <para>
                                    xx.yy.
                                </para>
                            </description>
                        </item>
                    </list>
                </para>
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO_UNION">
            <summary>
                Union for the OemId, ProcessorArchitecture, and Reserved fields of the
                <see cref="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO"/> structure.
            </summary>
            <seealso cref="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO"/>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO_UNION.OemId">
            <summary>
                <para>
                    An obsolete member that is retained for compatibility with Windows NT 3.5
                    and earlier.  New applications should use the <i>ProcessorArchitecture</i>
                    branch of the union.
                </para>
                <para>
                    <b>Windows Me/98/95:</b>  The system always sets this member to zero, the
                    value defined for <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_INTEL"/>.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO_UNION.ProcessorArchitecture">
            <summary>
                <para>
                    System's processor architecture.  This value can be one of the following
                    values:
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_UNKNOWN"/>
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_INTEL"/>
                </para>
                <para>
                    <b>Windows NT 3.51:</b>  <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_MIPS"/>
                </para>
                <para>
                    <b>Windows NT 4.0 and earlier:</b>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_ALPHA"/>
                </para>
                <para>
                    <b>Windows NT 4.0 and earlier:</b>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_PPC"/>
                </para>
                <para>
                    <b>64-bit Windows:</b>  <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_IA64"/>,
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_IA32_ON_WIN64"/>,
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_AMD64"/>
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO_UNION.Reserved">
            <summary>
                Reserved for future use.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.SimpleOpenGlControl">
            <summary>
                Provides a simple OpenGL control allowing quick development of Windows Forms-based
                OpenGL applications.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.#ctor">
            <summary>
                Constructor.  Creates contexts and sets properties.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.Dispose(System.Boolean)">
            <summary>
                Disposes the control.
            </summary>
            <param name="disposing">Was the disposed manually called?</param>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.InitializeBackground">
            <summary>
                Loads the bitmap from the assembly's manifest resource.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.InitializeComponent">
            <summary>
                Required for designer support.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.InitializeStyles">
            <summary>
                Initializes the control's styles.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.DestroyContexts">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.Draw">
            <summary>
                Sends an <see cref="!:UserControl.Invalidate"/> command to this control, thus
                forcing a redraw to occur.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.InitializeContexts">
            <summary>
                Creates the OpenGL contexts.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.MakeCurrent">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.SwapBuffers">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
                Paints the control.
            </summary>
            <param name="e">The paint event arguments.</param>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.OnPaintBackground(System.Windows.Forms.PaintEventArgs)">
            <summary>
                Paints the background.
            </summary>
            <param name="e"></param>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.AccumBits">
            <summary>
                Gets and sets the OpenGL control's accumulation buffer depth.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.ColorBits">
            <summary>
                Gets and sets the OpenGL control's color buffer depth.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.DepthBits">
            <summary>
                Gets and sets the OpenGL control's depth buffer (Z-buffer) depth.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.StencilBits">
            <summary>
                Gets and sets the OpenGL control's stencil buffer depth.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.AutoCheckErrors">
            <summary>
                Gets and sets the OpenGL control's automatic sending of a glGetError command
                after drawing.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.AutoFinish">
            <summary>
                Gets and sets the OpenGL control's automatic sending of a glFinish command
                after drawing.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.AutoMakeCurrent">
            <summary>
                Gets and sets the OpenGL control's automatic forcing of the rendering context to
                be current before drawing.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.AutoSwapBuffers">
            <summary>
                Gets and sets the OpenGL control's automatic sending of a SwapBuffers command
                after drawing.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.CreateParams">
            <summary>
                Overrides the control's class style parameters.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.User">
            <summary>
                User binding for .NET, implementing Windows-specific user functionality.
            </summary>
            <remarks>
                Binds functions and definitions in user32.dll.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.User.USER_NATIVE_LIBRARY">
            <summary>
                Specifies User32's native library archive.
            </summary>
            <remarks>
                Specifies user32.dll for Windows.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.User.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.StdCall"/>.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_VREDRAW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_HREDRAW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_DBLCLKS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_OWNDC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_CLASSDC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_PARENTDC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_NOCLOSE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_SAVEBITS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_BYTEALIGNCLIENT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_BYTEALIGNWINDOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_GLOBALCLASS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_IME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_DROPSHADOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CDS_UPDATEREGISTRY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CDS_TEST">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CDS_FULLSCREEN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.DISP_CHANGE_SUCCESSFUL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.DISP_CHANGE_RESTART">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.DISP_CHANGE_FAILED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.ENUM_CURRENT_SETTINGS">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.User.#ctor">
            <summary>
                Prevents instantiation.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.User.ChangeDisplaySettings(Tao.Platform.Windows.Gdi.DEVMODE@,System.Int32)">
            <summary>
                <para>
                    The <b>ChangeDisplaySettings</b> function changes the settings of the default
                    display device to the specified graphics mode.
                </para>
                <para>
                    To change the settings of a specified display device, use the
                    <b>ChangeDisplaySettingsEx</b> function.
                </para>
            </summary>
            <param name="devMode">
                <para>
                    Pointer to a <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure that describes the new
                    graphics mode.  If <i>devMode</i> is NULL, all the values currently in the
                    registry will be used for the display setting.  Passing NULL for the
                    <i>devMode</i> parameter and 0 for the <i>flags</i> parameter is the easiest
                    way to return to the default mode after a dynamic mode change.
                </para>
                <para>
                    The <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmSize"/> member of <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
                    must be initialized to the size, in bytes, of the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
                    structure.  The <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDriverExtra"/> member of
                    <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> must be initialized to indicate the number of bytes
                    of private driver data following the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure.  In
                    addition, you can use any or all of the following members of the
                    <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmBitsPerPel"/></term>
                            <description>Bits per pixel.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsWidth"/></term>
                            <description>Pixel width.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsHeight"/></term>
                            <description>Pixel height.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFlags"/></term>
                            <description>Mode flags.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFrequency"/></term>
                            <description>Mode frequency.</description>
                        </item>
                        <item>
                            <term>dmPosition</term>
                            <description>
                                <b>Windows 98/Me, Windows 2000/XP:</b> Position of the device in
                                a multimonitor configuration.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    In addition to using one or more of the preceding <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
                    members, you must also set one or more of the following values in the
                    <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmFields"/> member to change the display setting:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_BITSPERPEL"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmBitsPerPel"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_PELSWIDTH"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsWidth"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_PELSHEIGHT"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsHeight"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_DISPLAYFLAGS"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFlags"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_DISPLAYFREQUENCY"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFrequency"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DM_POSITION"/></term>
                            <description>
                                <b>Windows 98/Me, Windows 2000/XP:</b> Use the dmPosition value.
                            </description>
                        </item>
                    </list>
                </para>
            </param>
            <param name="flags">
                <para>
                    Indicates how the graphics mode should be changed.  This parameter can be one
                    of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>0</term>
                            <description>
                                The graphics mode for the current screen will be changed
                                dynamically.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_FULLSCREEN"/></term>
                            <description>
                                <para>
                                    The mode is temporary in nature.
                                </para>
                                <para>
                                    <b>Windows NT/2000/XP:</b> If you change to and from another
                                    desktop, this mode will not be reset.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_GLOBAL"/></term>
                            <description>
                                The settings will be saved in the global settings area so that
                                they will affect all users on the machine.  Otherwise, only the
                                settings for the user are modified.  This flag is only valid when
                                specified with the <see cref="!:Gdi.CDS_UPDATEREGISTRY"/> flag.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_NORESET"/></term>
                            <description>
                                The settings will be saved in the registry, but will not take
                                affect.  This flag is only valid when specified with the
                                <see cref="!:Gdi.CDS_UPDATEREGISTRY"/> flag.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_RESET"/></term>
                            <description>
                                The settings should be changed, even if the requested settings are
                                the same as the current settings.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_SET_PRIMARY"/></term>
                            <description>
                                This device will become the primary device.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_TEST"/></term>
                            <description>
                                The system tests if the requested graphics mode could be set.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_UPDATEREGISTRY"/></term>
                            <description>
                                The graphics mode for the current screen will be changed
                                dynamically and the graphics mode will be updated in the registry.
                                The mode information is stored in the USER profile.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    Specifying <see cref="!:Gdi.CDS_TEST"/> allows an application to determine
                    which graphics modes are actually valid, without causing the system to
                    change to that graphics mode.
                </para>
                <para>
                    If <see cref="!:Gdi.CDS_UPDATEREGISTRY"/> is specified and it is possible to
                    change the graphics mode dynamically, the information is stored in the
                    registry and <see cref="!:Gdi.DISP_CHANGE_SUCCESSFUL"/> is returned.  If it is
                    not possible to change the graphics mode dynamically, the information is
                    stored in the registry and <see cref="!:Gdi.DISP_CHANGE_RESTART"/> is returned.
                </para>
                <para>
                    <b>Windows NT/2000/XP:</b>  If <see cref="!:Gdi.CDS_UPDATEREGISTRY"/> is
                    specified and the information could not be stored in the registry, the
                    graphics mode is not changed and <see cref="!:Gdi.DISP_CHANGE_NOTUPDATED"/> is
                    returned.
                </para>
            </param>
            <returns>
                <para>
                    The <b>ChangeDisplaySettings</b> function returns one of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_SUCCESSFUL"/></term>
                            <description>
                                The settings change was successful.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_BADDUALVIEW"/></term>
                            <description>
                                <b>Windows XP:</b>  The settings change was unsuccessful because
                                system is DualView capable.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_BADFLAGS"/></term>
                            <description>
                                An invalid set of flags was passed in.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_BADMODE"/></term>
                            <description>
                                The graphics mode is not supported.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_BADPARAM"/></term>
                            <description>
                                An invalid parameter was passed in.  This can include an invalid
                                flag or combination of flags.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_FAILED"/></term>
                            <description>
                                The display driver failed the specified graphics mode.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_NOTUPDATED"/></term>
                            <description>
                                <b>Windows NT/2000/XP:</b>  Unable to write settings to the
                                registry.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_RESTART"/></term>
                            <description>
                                The computer must be restarted in order for the graphics mode to
                                work.
                            </description>
                        </item>
                    </list>
                </para>
            </returns>
            <remarks>
                <para>
                    To ensure that the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure passed to
                    <b>ChangeDisplaySettings</b> is valid and contains only values supported by
                    the display driver, use the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> returned by the
                    <see cref="M:Tao.Platform.Windows.User.EnumDisplaySettings(System.String,System.Int32,Tao.Platform.Windows.Gdi.DEVMODE@)"/> function.
                </para>
                <para>
                    When the display mode is changed dynamically, the <b>WM_DISPLAYCHANGE</b>
                    message is sent to all running applications with the following message
                    parameters:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>wParam</term>
                            <description>New bits per pixel.</description>
                        </item>
                        <item>
                            <term>LOWORD(lParam)</term>
                            <description>New pixel width.</description>
                        </item>
                        <item>
                            <term>HIWORD(lParam)</term>
                            <description>New pixel height.</description>
                        </item>
                    </list>
                </para>
                <para>
                    <b>Windows 95/98/Me:</b>  If the calling thread has any windows,
                    <b>ChangeDisplaySettings</b> sends them the <b>WM_DISPLAYCHANGE</b> message
                    immediately (for windows in all other threads, the message is sent when the
                    thread can receive nonqueued messages).  This may cause the shell to get its
                    message too soon and could squash icons.  To avoid this problem, have
                    <b>ChangeDisplaySettings</b> do resolution switching by calling on a thread
                    with no windows, for example, a new thread.
                </para>
            </remarks>
            <seealso cref="!:CreateDC"/>
            <seealso cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
            <seealso cref="M:Tao.Platform.Windows.User.EnumDisplaySettings(System.String,System.Int32,Tao.Platform.Windows.Gdi.DEVMODE@)"/>
        </member>
        <member name="M:Tao.Platform.Windows.User.ChangeDisplaySettings(System.IntPtr,System.Int32)">
            <summary>
                <para>
                    The <b>ChangeDisplaySettings</b> function changes the settings of the default
                    display device to the specified graphics mode.
                </para>
                <para>
                    To change the settings of a specified display device, use the
                    <b>ChangeDisplaySettingsEx</b> function.
                </para>
            </summary>
            <param name="devMode">
                <para>
                    Pointer to a <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure that describes the new
                    graphics mode.  If <i>devMode</i> is NULL, all the values currently in the
                    registry will be used for the display setting.  Passing NULL for the
                    <i>devMode</i> parameter and 0 for the <i>flags</i> parameter is the easiest
                    way to return to the default mode after a dynamic mode change.
                </para>
                <para>
                    The <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmSize"/> member of <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
                    must be initialized to the size, in bytes, of the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
                    structure.  The <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDriverExtra"/> member of
                    <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> must be initialized to indicate the number of bytes
                    of private driver data following the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure.  In
                    addition, you can use any or all of the following members of the
                    <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmBitsPerPel"/></term>
                            <description>Bits per pixel.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsWidth"/></term>
                            <description>Pixel width.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsHeight"/></term>
                            <description>Pixel height.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFlags"/></term>
                            <description>Mode flags.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFrequency"/></term>
                            <description>Mode frequency.</description>
                        </item>
                        <item>
                            <term>dmPosition</term>
                            <description>
                                <b>Windows 98/Me, Windows 2000/XP:</b> Position of the device in
                                a multimonitor configuration.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    In addition to using one or more of the preceding <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
                    members, you must also set one or more of the following values in the
                    <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmFields"/> member to change the display setting:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_BITSPERPEL"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmBitsPerPel"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_PELSWIDTH"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsWidth"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_PELSHEIGHT"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsHeight"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_DISPLAYFLAGS"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFlags"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_DISPLAYFREQUENCY"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFrequency"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DM_POSITION"/></term>
                            <description>
                                <b>Windows 98/Me, Windows 2000/XP:</b> Use the dmPosition value.
                            </description>
                        </item>
                    </list>
                </para>
            </param>
            <param name="flags">
                <para>
                    Indicates how the graphics mode should be changed.  This parameter can be one
                    of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>0</term>
                            <description>
                                The graphics mode for the current screen will be changed
                                dynamically.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_FULLSCREEN"/></term>
                            <description>
                                <para>
                                    The mode is temporary in nature.
                                </para>
                                <para>
                                    <b>Windows NT/2000/XP:</b> If you change to and from another
                                    desktop, this mode will not be reset.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_GLOBAL"/></term>
                            <description>
                                The settings will be saved in the global settings area so that
                                they will affect all users on the machine.  Otherwise, only the
                                settings for the user are modified.  This flag is only valid when
                                specified with the <see cref="!:Gdi.CDS_UPDATEREGISTRY"/> flag.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_NORESET"/></term>
                            <description>
                                The settings will be saved in the registry, but will not take
                                affect.  This flag is only valid when specified with the
                                <see cref="!:Gdi.CDS_UPDATEREGISTRY"/> flag.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_RESET"/></term>
                            <description>
                                The settings should be changed, even if the requested settings are
                                the same as the current settings.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_SET_PRIMARY"/></term>
                            <description>
                                This device will become the primary device.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_TEST"/></term>
                            <description>
                                The system tests if the requested graphics mode could be set.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.CDS_UPDATEREGISTRY"/></term>
                            <description>
                                The graphics mode for the current screen will be changed
                                dynamically and the graphics mode will be updated in the registry.
                                The mode information is stored in the USER profile.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    Specifying <see cref="!:Gdi.CDS_TEST"/> allows an application to determine
                    which graphics modes are actually valid, without causing the system to
                    change to that graphics mode.
                </para>
                <para>
                    If <see cref="!:Gdi.CDS_UPDATEREGISTRY"/> is specified and it is possible to
                    change the graphics mode dynamically, the information is stored in the
                    registry and <see cref="!:Gdi.DISP_CHANGE_SUCCESSFUL"/> is returned.  If it is
                    not possible to change the graphics mode dynamically, the information is
                    stored in the registry and <see cref="!:Gdi.DISP_CHANGE_RESTART"/> is returned.
                </para>
                <para>
                    <b>Windows NT/2000/XP:</b>  If <see cref="!:Gdi.CDS_UPDATEREGISTRY"/> is
                    specified and the information could not be stored in the registry, the
                    graphics mode is not changed and <see cref="!:Gdi.DISP_CHANGE_NOTUPDATED"/> is
                    returned.
                </para>
            </param>
            <returns>
                <para>
                    The <b>ChangeDisplaySettings</b> function returns one of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_SUCCESSFUL"/></term>
                            <description>
                                The settings change was successful.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_BADDUALVIEW"/></term>
                            <description>
                                <b>Windows XP:</b>  The settings change was unsuccessful because
                                system is DualView capable.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_BADFLAGS"/></term>
                            <description>
                                An invalid set of flags was passed in.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_BADMODE"/></term>
                            <description>
                                The graphics mode is not supported.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_BADPARAM"/></term>
                            <description>
                                An invalid parameter was passed in.  This can include an invalid
                                flag or combination of flags.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_FAILED"/></term>
                            <description>
                                The display driver failed the specified graphics mode.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_NOTUPDATED"/></term>
                            <description>
                                <b>Windows NT/2000/XP:</b>  Unable to write settings to the
                                registry.
                            </description>
                        </item>
                        <item>
                            <term><see cref="!:Gdi.DISP_CHANGE_RESTART"/></term>
                            <description>
                                The computer must be restarted in order for the graphics mode to
                                work.
                            </description>
                        </item>
                    </list>
                </para>
            </returns>
            <remarks>
                <para>
                    To ensure that the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure passed to
                    <b>ChangeDisplaySettings</b> is valid and contains only values supported by
                    the display driver, use the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> returned by the
                    <see cref="M:Tao.Platform.Windows.User.EnumDisplaySettings(System.String,System.Int32,Tao.Platform.Windows.Gdi.DEVMODE@)"/> function.
                </para>
                <para>
                    When the display mode is changed dynamically, the <b>WM_DISPLAYCHANGE</b>
                    message is sent to all running applications with the following message
                    parameters:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>wParam</term>
                            <description>New bits per pixel.</description>
                        </item>
                        <item>
                            <term>LOWORD(lParam)</term>
                            <description>New pixel width.</description>
                        </item>
                        <item>
                            <term>HIWORD(lParam)</term>
                            <description>New pixel height.</description>
                        </item>
                    </list>
                </para>
                <para>
                    <b>Windows 95/98/Me:</b>  If the calling thread has any windows,
                    <b>ChangeDisplaySettings</b> sends them the <b>WM_DISPLAYCHANGE</b> message
                    immediately (for windows in all other threads, the message is sent when the
                    thread can receive nonqueued messages).  This may cause the shell to get its
                    message too soon and could squash icons.  To avoid this problem, have
                    <b>ChangeDisplaySettings</b> do resolution switching by calling on a thread
                    with no windows, for example, a new thread.
                </para>
            </remarks>
            <seealso cref="!:CreateDC"/>
            <seealso cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
            <seealso cref="M:Tao.Platform.Windows.User.EnumDisplaySettings(System.String,System.Int32,Tao.Platform.Windows.Gdi.DEVMODE@)"/>
        </member>
        <member name="M:Tao.Platform.Windows.User.EnumDisplaySettings(System.String,System.Int32,Tao.Platform.Windows.Gdi.DEVMODE@)">
            <summary>
            
            </summary>
            <param name="deviceName"></param>
            <param name="modeNumber"></param>
            <param name="devMode"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.User.GetDC(System.IntPtr)">
            <summary>
                <para>
                    The <b>GetDC</b> function retrieves a handle to a display device context (DC)
                    for the client area of a specified window or for the entire screen.  You can
                    use the returned handle in subsequent GDI functions to draw in the DC.
                </para>
                <para>
                    The <see cref="!:GetDCEx"/> function is an extension to <b>GetDC</b>, which
                    gives an application more control over how and whether clipping occurs in the
                    client area.
                </para>
            </summary>
            <param name="windowHandle">
                <para>
                    Handle to the window whose DC is to be retrieved.  If this value is null,
                    <b>GetDC</b> retrieves the DC for the entire screen.
                </para>
                <para>
                    <b>Windows 98/Me, Windows 2000/XP:</b> To get the DC for a specific display
                    monitor, use the <see cref="!:EnumDisplayMonitors"/> and
                    <see cref="!:Gdi.CreateDC"/> functions.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is a handle to the DC for the
                    specified window's client area.
                </para>
                <para>
                    If the function fails, the return value is null.
                </para>
                <para>
                    <b>Windows NT/2000/XP:</b> To get extended error information, call
                    <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The <b>GetDC</b> function retrieves a common, class, or private DC depending
                    on the class style of the specified window.  For class and private DCs,
                    <b>GetDC</b> leaves the previously assigned attributes unchanged.  However,
                    for common DCs, <b>GetDC</b> assigns default attributes to the DC each time
                    it is retrieved.  For example, the default font is System, which is a bitmap
                    font.  Because of this, the handle for a common DC returned by <b>GetDC</b>
                    does not tell you what font, color, or brush was used when the window was
                    drawn.  To determine the font, call <see cref="!:GetTextFace"/>.
                </para>
                <para>
                    Note that the handle to the DC can only be used by a single thread at any one
                    time.
                </para>
                <para>
                    After painting with a common DC, the <see cref="M:Tao.Platform.Windows.User.ReleaseDC(System.IntPtr,System.IntPtr)"/> function must
                    be called to release the DC.  Class and private DCs do not have to be
                    released.  <see cref="M:Tao.Platform.Windows.User.ReleaseDC(System.IntPtr,System.IntPtr)"/> must be called from the same thread that
                    called <b>GetDC</b>.  The number of DCs is limited only by available memory.
                </para>
                <para>
                    <b>Windows 95/98/Me:</b> There are only 5 common DCs available per thread,
                    thus failure to release a DC can prevent other applications from accessing
                    one.
                </para>
            </remarks>
            <seealso cref="!:GetDCEx"/>
            <seealso cref="M:Tao.Platform.Windows.User.ReleaseDC(System.IntPtr,System.IntPtr)"/>
            <seealso cref="!:GetTextFace"/>
            <seealso cref="!:GetWindowDC"/>
        </member>
        <member name="M:Tao.Platform.Windows.User.ReleaseDC(System.IntPtr,System.IntPtr)">
            <summary>
                <para>
                    The <b>ReleaseDC</b> function releases a device context (DC), freeing it for
                    use by other applications.  The effect of the <b>ReleaseDC</b> function
                    depends on the type of DC.  It frees only common and window DCs.  It has no
                    effect on class or private DCs.
                </para>
            </summary>
            <param name="windowHandle">
                <para>
                    Handle to the window whose DC is to be released.
                </para>
            </param>
            <param name="deviceContext">
                <para>
                    Handle to the DC to be released.
                </para>
            </param>
            <returns>
                <para>
                    The return value indicates whether the DC was released.  If the DC was
                    released, the return value is true.
                </para>
                <para>
                    If the DC was not released, the return value is false.
                </para>
            </returns>
            <remarks>
                <para>
                    The application must call the <b>ReleaseDC</b> function for each call to the
                    <see cref="!:GetWindowDC"/> function and for each call to the
                    <see cref="M:Tao.Platform.Windows.User.GetDC(System.IntPtr)"/> function that retrieves a common DC.
                </para>
                <para>
                    An application cannot use the <b>ReleaseDC</b> function to release a DC that
                    was created by calling the <see cref="!:Gdi.CreateDC"/> function; instead, it
                    must use the <see cref="!:Gdi.DeleteDC"/> function.  <b>ReleaseDC</b> must be
                    called from the same thread that called <b>GetDC</b>.
                </para>
            </remarks>
            <seealso cref="!:Gdi.CreateDC"/>
            <seealso cref="!:Gdi.DeleteDC"/>
            <seealso cref="M:Tao.Platform.Windows.User.GetDC(System.IntPtr)"/>
            <seealso cref="!:GetWindowDC"/>
        </member>
        <member name="T:Tao.Platform.Windows.Wgl">
            <summary>
                <para>
                    WGL binding for .NET, implementing Windows-specific OpenGL functionality.
                </para>
            </summary>
            <remarks>
                <para>
                    Binds the wgl functions and definitions in opengl32.dll.
                </para>
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NATIVE_LIBRARY">
            <summary>
                <para>
                    Specifies WGL's native library archive.
                </para>
            </summary>
            <remarks>
                <para>
                    Specifies opengl32.dll for Windows.
                </para>
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.StdCall"/>.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_MAIN_PLANE">
            <summary>
                <para>
                    Swaps the front and back buffers of the main plane.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY1">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 1.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY2">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 2.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY3">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 3.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY4">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 4.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY5">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 5.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY6">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 6.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY7">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 7.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY8">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 8.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY9">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 9.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY10">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 10.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY11">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 11.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY12">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 12.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY13">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 13.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY14">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 14.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_OVERLAY15">
            <summary>
                <para>
                    Swaps the front and back buffers of the overlay plane 15.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY1">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 1.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY2">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 2.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY3">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 3.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY4">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 4.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY5">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 5.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY6">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 6.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY7">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 7.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY8">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 8.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY9">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 9.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY10">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 10.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY11">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 11.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY12">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 12.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY13">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 13.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY14">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 14.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDERLAY15">
            <summary>
                <para>
                    Swaps the front and back buffers of the underlay plane 15.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_FONT_LINES">
            <summary>
                <para>
                    Fonts with line segments.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_FONT_POLYGONS">
            <summary>
                <para>
                    Fonts with polygons.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SAMPLE_BUFFERS_3DFX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SAMPLES_3DFX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_FRONT_COLOR_BUFFER_BIT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BACK_COLOR_BUFFER_BIT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DEPTH_BUFFER_BIT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_STENCIL_BUFFER_BIT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SAMPLE_BUFFERS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SAMPLES_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NUMBER_PIXEL_FORMATS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DRAW_TO_WINDOW_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DRAW_TO_BITMAP_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ACCELERATION_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NEED_PALETTE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NEED_SYSTEM_PALETTE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_LAYER_BUFFERS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_METHOD_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NUMBER_OVERLAYS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NUMBER_UNDERLAYS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TRANSPARENT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TRANSPARENT_RED_VALUE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TRANSPARENT_GREEN_VALUE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TRANSPARENT_BLUE_VALUE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TRANSPARENT_ALPHA_VALUE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TRANSPARENT_INDEX_VALUE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SHARE_DEPTH_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SHARE_STENCIL_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SHARE_ACCUM_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SUPPORT_GDI_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SUPPORT_OPENGL_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DOUBLE_BUFFER_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_STEREO_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_PIXEL_TYPE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_COLOR_BITS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_RED_BITS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_RED_SHIFT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GREEN_BITS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GREEN_SHIFT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BLUE_BITS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BLUE_SHIFT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ALPHA_BITS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ALPHA_SHIFT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ACCUM_BITS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ACCUM_RED_BITS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ACCUM_GREEN_BITS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ACCUM_BLUE_BITS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ACCUM_ALPHA_BITS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DEPTH_BITS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_STENCIL_BITS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_AUX_BUFFERS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NO_ACCELERATION_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GENERIC_ACCELERATION_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_FULL_ACCELERATION_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_EXCHANGE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_COPY_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDEFINED_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TYPE_RGBA_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TYPE_COLORINDEX_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ERROR_INVALID_PIXEL_TYPE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DRAW_TO_PBUFFER_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_MAX_PBUFFER_PIXELS_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_MAX_PBUFFER_WIDTH_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_MAX_PBUFFER_HEIGHT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_PBUFFER_LARGEST_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_PBUFFER_WIDTH_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_PBUFFER_HEIGHT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_PBUFFER_LOST_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BIND_TO_TEXTURE_RGB_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BIND_TO_TEXTURE_RGBA_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_FORMAT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_TARGET_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_MIPMAP_TEXTURE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_RGB_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_RGBA_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NO_TEXTURE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_CUBE_MAP_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_1D_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_2D_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_MIPMAP_LEVEL_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_CUBE_MAP_FACE_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_FRONT_LEFT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_FRONT_RIGHT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BACK_LEFT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BACK_RIGHT_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_AUX0_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_AUX1_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_AUX2_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_AUX3_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_AUX4_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_AUX5_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_AUX6_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_AUX7_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_AUX8_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_AUX9_ARB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_RGBA_FLOAT_MODE_ATI">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TYPE_RGBA_FLOAT_ATI">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NUMBER_PIXEL_FORMATS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DRAW_TO_WINDOW_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DRAW_TO_BITMAP_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ACCELERATION_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NEED_PALETTE_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NEED_SYSTEM_PALETTE_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_LAYER_BUFFERS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_METHOD_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NUMBER_OVERLAYS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NUMBER_UNDERLAYS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TRANSPARENT_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TRANSPARENT_VALUE_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SHARE_DEPTH_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SHARE_STENCIL_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SHARE_ACCUM_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SUPPORT_GDI_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SUPPORT_OPENGL_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DOUBLE_BUFFER_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_STEREO_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_PIXEL_TYPE_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_COLOR_BITS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_RED_BITS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_RED_SHIFT_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GREEN_BITS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GREEN_SHIFT_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BLUE_BITS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BLUE_SHIFT_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ALPHA_BITS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ALPHA_SHIFT_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ACCUM_BITS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ACCUM_RED_BITS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ACCUM_GREEN_BITS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ACCUM_BLUE_BITS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_ACCUM_ALPHA_BITS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DEPTH_BITS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_STENCIL_BITS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_AUX_BUFFERS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_NO_ACCELERATION_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GENERIC_ACCELERATION_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_FULL_ACCELERATION_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_EXCHANGE_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_COPY_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SWAP_UNDEFINED_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TYPE_RGBA_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TYPE_COLORINDEX_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DEPTH_FLOAT_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SAMPLE_BUFFERS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_SAMPLES_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DRAW_TO_PBUFFER_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_MAX_PBUFFER_PIXELS_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_MAX_PBUFFER_WIDTH_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_MAX_PBUFFER_HEIGHT_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_OPTIMAL_PBUFFER_WIDTH_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_OPTIMAL_PBUFFER_HEIGHT_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_PBUFFER_LARGEST_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_PBUFFER_WIDTH_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_PBUFFER_HEIGHT_EXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DIGITAL_VIDEO_CURSOR_ALPHA_VALUE_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DIGITAL_VIDEO_CURSOR_INCLUDED_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DIGITAL_VIDEO_GAMMA_CORRECTED_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GAMMA_TABLE_SIZE_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GAMMA_EXCLUDE_DESKTOP_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GENLOCK_SOURCE_MULTIVIEW_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GENLOCK_SOURCE_EXTERNAL_SYNC_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GENLOCK_SOURCE_EXTERNAL_FIELD_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GENLOCK_SOURCE_EXTERNAL_TTL_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GENLOCK_SOURCE_DIGITAL_SYNC_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GENLOCK_SOURCE_DIGITAL_FIELD_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GENLOCK_SOURCE_EDGE_FALLING_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GENLOCK_SOURCE_EDGE_RISING_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_GENLOCK_SOURCE_EDGE_BOTH_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_IMAGE_BUFFER_MIN_ACCESS_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_IMAGE_BUFFER_LOCK_I3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BIND_TO_TEXTURE_DEPTH_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DEPTH_TEXTURE_FORMAT_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_DEPTH_COMPONENT_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_DEPTH_COMPONENT_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BIND_TO_TEXTURE_RECTANGLE_RGB_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BIND_TO_TEXTURE_RECTANGLE_RGBA_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_RECTANGLE_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_FLOAT_COMPONENTS_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_FLOAT_R_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_FLOAT_RG_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_FLOAT_RGB_NV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.WGL_TEXTURE_FLOAT_RGBA_NV">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.#ctor">
            <summary>
                Prevents instantiation.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCopyContext(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
                <para>
                    The <b>wglCopyContext</b> function copies selected groups of rendering
                    states from one OpenGL rendering context to another.
                </para>
            </summary>
            <param name="source">
                <para>
                    Specifies the source OpenGL rendering context whose state information is to
                    be copied.
                </para>
            </param>
            <param name="destination">
                <para>
                    Specifies the destination OpenGL rendering context to which state information
                    is to be copied.
                </para>
            </param>
            <param name="mask">
                <para>
                    Specifies which groups of the <i>source</i> rendering state are to be copied
                    to <i>destination</i>.  It contains the bitwise-OR of the same symbolic names
                    that are passed to the <see cref="M:Tao.OpenGl.Gl.glPushAttrib(System.Int32)"/> function.
                    You can use <see cref="F:Tao.OpenGl.Gl.GL_ALL_ATTRIB_BITS"/> to copy all the
                    rendering state information.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.  If the function fails,
                    the return value is false.  To get extended error information, call
                    <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    Using the <b>wglCopyContext</b> function, you can synchronize the rendering
                    state of two rendering contexts.  You can only copy the rendering state
                    between two rendering contexts within the same process.  The rendering
                    contexts must be from the same OpenGL implementation.  For example, you can
                    always copy a rendering state between two rendering contexts with identical
                    pixel format in the same process.
                </para>
                <para>
                    You can copy the same state information available only with the
                    <see cref="M:Tao.OpenGl.Gl.glPushAttrib(System.Int32)"/> function.  You cannot copy some
                    state information, such as pixel pack/unpack state, render mode state, select
                    state, and feedback state.  When you call <b>wglCopyContext</b>, make sure
                    that the destination rendering context, <i>destination</i>, is not current to
                    any thread.
                </para>
            </remarks>
            <seealso cref="M:Tao.OpenGl.Gl.glPushAttrib(System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglCreateContext(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglCreateLayerContext(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglShareLists(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreateContext(System.IntPtr)">
            <summary>
                <para>
                    The <b>wglCreateContext</b> function creates a new OpenGL rendering context,
                    which is suitable for drawing on the device referenced by
                    <i>deviceContext</i>.  The rendering context has the same pixel format as
                    the device context.
                </para>
            </summary>
            <param name="deviceContext">
                <para>
                    Handle to a device context for which the function creates a suitable OpenGL
                    rendering context.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is a valid handle to an OpenGL
                    rendering context.
                </para>
                <para>
                    If the function fails, the return value is <see cref="F:System.IntPtr.Zero"/>.  To get
                    extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    A rendering context is not the same as a device context.  Set the pixel
                    format of the device context before creating a rendering context.  For more
                    information on setting the device context's pixel format, see the
                    <see cref="M:Tao.Platform.Windows.Gdi.SetPixelFormat(System.IntPtr,System.Int32,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/> function.
                </para>
                <para>
                    To use OpenGL, you create a rendering context, select it as a thread's
                    current rendering context, and then call OpenGL functions.  When you are
                    finished with the rendering context, you dispose of it by calling the
                    <see cref="M:Tao.Platform.Windows.Wgl.wglDeleteContext(System.IntPtr)"/> function.
                </para>
                <para>
                    The following code example shows <b>wglCreateContext</b> usage:
                </para>
                <para>
                    <code>
                        IntPtr hdc;
                        IntPtr hglrc;
                                    // create a device context
                                    // create a rendering context
                        hglrc = Wgl.wglCreateContext(hdc);
                                    // make it the calling thread's current rendering context
                        Wgl.wglMakeCurrent(hdc, hglrc);
                                    // call OpenGL APIs as desired...
                                    // when the rendering context is no longer needed...
                                    // make the rendering context not current
                        Wgl.wglMakeCurrent(IntPtr.Zero, IntPtr.Zero);
                                    // delete the rendering context
                        Wgl.wglDeleteContext(hglrc);
                    </code>
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Gdi.SetPixelFormat(System.IntPtr,System.Int32,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglDeleteContext(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglGetCurrentContext"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglGetCurrentDC"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreateLayerContext(System.IntPtr,System.Int32)">
            <summary>
                <para>
                    The <b>wglCreateLayerContext</b> function creates a new OpenGL rendering
                    context for drawing to a specified layer plane on a device context.
                </para>
            </summary>
            <param name="deviceContext">
                <para>
                    Specifies the device context for a new rendering context.
                </para>
            </param>
            <param name="layerPlane">
                <para>
                    Specifies the layer plane to which you want to bind a rendering context.  The
                    value 0 identifies the main plane.  Positive values of <i>layerPlane</i>
                    identify overlay planes, where 1 is the first overlay plane over the main
                    plane, 2 is the second overlay plane over the first overlay plane, and so on.
                    Negative values identify underlay planes, where 1 is the first underlay
                    plane under the main plane, 2 is the second underlay plane under the first
                    underlay plane, and so on.  The number of overlay and underlay planes is
                    given in the <b>bReserved</b> member of the
                    <see cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/> structure.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is a handle to an OpenGL rendering
                    context.
                </para>
                <para>
                    If the function fails, the return value is <see cref="F:System.IntPtr.Zero"/>.  To get
                    extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    A rendering context is a port through which all OpenGL commands pass.  Every
                    thread that makes OpenGL calls must have one current, active rendering
                    context.  A rendering context is not the same as a device context; a
                    rendering context contains information specific to OpenGL, while a device
                    context contains information specific to GDI.
                </para>
                <para>
                    Before you create a rendering context, set the pixel format of the device
                    context with the <see cref="M:Tao.Platform.Windows.Gdi.SetPixelFormat(System.IntPtr,System.Int32,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/> function.  You can use a
                    rendering context in a specified layer plane of a window with identical pixel
                    formats only.
                </para>
                <para>
                    With OpenGL applications that use multiple threads, you create a rendering
                    context, select it as the current rendering context of a thread, and make
                    OpenGL calls for the specified thread.  When you are finished with the
                    rendering context of the thread, call the
                    <see cref="M:Tao.Platform.Windows.Wgl.wglDeleteContext(System.IntPtr)"/> function.
                </para>
                <para>
                    The following code example shows how to use <b>wglCreateLayerContext</b>.
                </para>
                <para>
                    <code>
                        // The following code fragment shows how to render to overlay 1
                        // This example assumes that the pixel format of hdc includes
                        // overlay plane 1
                                    IntPtr hdc;
                        IntPtr hglrc;
                                    // create a rendering context for overlay plane 1
                        hglrc = Wgl.wglCreateLayerContext(hdc, 1);
                                    // make it the calling thread's current rendering context
                        Wgl.wglMakeCurrent(hdc, hglrc);
                                    // call OpenGL functions here...
                                    // when the rendering context is no longer needed...
                                    // make the rendering context not current
                        Wgl.wglMakeCurrent(IntPtr.Zero, IntPtr.Zero);
                                    // delete the rendering context
                        Wgl.wglDeleteContext(hglrc);
                    </code>
                </para>
            </remarks>
            <seealso cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/>
            <seealso cref="M:Tao.Platform.Windows.Gdi.SetPixelFormat(System.IntPtr,System.Int32,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglCreateContext(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglDeleteContext(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglGetCurrentContext"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglGetCurrentDC"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglDeleteContext(System.IntPtr)">
            <summary>
                <para>
                    The <b>wglDeleteContext</b> function deletes a specified OpenGL rendering
                    context.
                </para>
            </summary>
            <param name="renderingContext">
                <para>
                    Handle to an OpenGL rendering context that the function will delete.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    It is an error to delete an OpenGL rendering context that is the current
                    context of another thread.  However, if a rendering context is the calling
                    thread's current context, the <b>wglDeleteContext</b> function changes the
                    rendering context to being not current before deleting it.
                </para>
                <para>
                    The <b>wglDeleteContext</b> function does not delete the device context
                    associated with the OpenGL rendering context when you call the
                    <b>wglMakeCurrent</b> function.  After calling <b>wglDeleteContext</b>, you
                    must call <see cref="!:Gdi.DeleteDC"/> to delete the associated device context.
                </para>
            </remarks>
            <seealso cref="!:Gdi.DeleteDC"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglCreateContext(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglGetCurrentContext"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglGetCurrentDC"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetCurrentContext">
            <summary>
                <para>
                    The <b>wglGetCurrentContext</b> function obtains a handle to the current
                    OpenGL rendering context of the calling thread.
                </para>
            </summary>
            <returns>
                <para>
                    If the calling thread has a current OpenGL rendering context,
                    <b>wglGetCurrentContext</b> returns a handle to that rendering context.
                    Otherwise, the return value is <see cref="F:System.IntPtr.Zero"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The current OpenGL rendering context of a thread is associated with a device
                    context by means of the <see cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/> function.  You can use
                    the <see cref="M:Tao.Platform.Windows.Wgl.wglGetCurrentDC"/> function to obtain a handle to the device
                    context associated with the current OpenGL rendering context.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglCreateContext(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglDeleteContext(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglGetCurrentDC"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetCurrentDC">
            <summary>
                <para>
                    The <b>wglGetCurrentDC</b> function obtains a handle to the device context
                    that is associated with the current OpenGL rendering context of the calling
                    thread.
                </para>
            </summary>
            <returns>
                <para>
                    If the calling thread has a current OpenGL rendering context, the function
                    returns a handle to the device context associated with that rendering context
                    by means of the <see cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/> function.  Otherwise, the
                    return value is <see cref="F:System.IntPtr.Zero"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    You associate a device context with an OpenGL rendering context when it calls
                    the <see cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/> function.  You can use the
                    <see cref="M:Tao.Platform.Windows.Wgl.wglGetCurrentContext"/> function to obtain a handle to the
                    calling thread's current OpenGL rendering context.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglCreateContext(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglDeleteContext(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglGetCurrentContext"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetLayerPaletteEntries(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>
                <para>
                    The <b>wglGetLayerPaletteEntries</b> function retrieves the palette entries
                    from a given color-index layer plane for a specified device context.
                </para>
            </summary>
            <param name="deviceContext">
                <para>
                    Specifies the device context of a window whose layer planes are to be
                    described.
                </para>
            </param>
            <param name="layerPlane">
                <para>
                    Specifies the overlay or underlay plane.  Positive values of
                    <i>layerPlane</i> identify overlay planes, where 1 is the first overlay plane
                    over the main plane, 2 is the second overlay plane over the first overlay
                    plane, and so on.  Negative values identify underlay planes, where 1 is the
                    first underlay plane under the main plane, 2 is the second underlay plane
                    under the first underlay plane, and so on.  The number of overlay and
                    underlay planes is given in the <b>bReserved</b> member of the
                    <see cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/> structure.
                </para>
            </param>
            <param name="start">
                <para>
                    Specifies the first palette entry to be retrieved.
                </para>
            </param>
            <param name="entries">
                <para>
                    Specifies the number of palette entries to be retrieved.
                </para>
            </param>
            <param name="colors">
                <para>
                    Points to an array of <see cref="T:System.Int32"/>'s that contain palette RGB color
                    values.  The array must contain at least as many structures as specified by
                    <i>entries</i>.
                </para>
                <para>
                    The color values should be a RGB value as an int in the hexidecimal form
                    of 0x00bbggrr.  The low-order byte contains a value for the relative
                    intensity of red; the second byte contains a value for green; and the third
                    byte contains a value for blue.  The high-order byte must be zero.  The
                    maximum value for a single byte is 0xFF.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the number of entries that were
                    set in the palette in the specified layer plane of the window.
                </para>
                <para>
                    If the function fails or when no pixel format is selected, the return value
                    is zero.  To get extended error information, call
                    <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    Each color-index layer plane in a window has a palette with a size 2^n, where
                    n is the number of bit planes in the layer plane.  You cannot modify the
                    transparent index of a palette.
                </para>
                <para>
                    Use the <see cref="M:Tao.Platform.Windows.Wgl.wglRealizeLayerPalette(System.IntPtr,System.Int32,System.Boolean)"/> function to realize the layer
                    palette.  Initially the layer palette contains only entries for white.
                </para>
                <para>
                    The <see cref="M:Tao.Platform.Windows.Wgl.wglSetLayerPaletteEntries(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[])"/> function doesn't set the palette
                    entries of the main plane palette.  To update the main plane palette, use
                    GDI palette functions.
                </para>
            </remarks>
            <seealso cref="!:Gdi.LAYERPLANEDESCRIPTOR"/>
            <seealso cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/>
            <seealso cref="!:wglDescribeLayerPlane"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglRealizeLayerPalette(System.IntPtr,System.Int32,System.Boolean)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglSetLayerPaletteEntries(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[])"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetProcAddress(System.String)">
            <summary>
                <para>
                    The <b>wglGetProcAddress</b> function returns the address of an OpenGL
                    extension function for use with the current OpenGL rendering context.
                </para>
            </summary>
            <param name="extension">
                <para>
                    Points to a null-terminated string that is the name of the extension
                    function.  The name of the extension function must be identical to a
                    corresponding function implemented by OpenGL.
                </para>
            </param>
            <returns>
                <para>
                    When the function succeeds, the return value is the address of the extension
                    function.
                </para>
                <para>
                    When no current rendering context exists or the function fails, the return
                    value is <see cref="F:System.IntPtr.Zero"/>.  To get extended error information, call
                    <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The OpenGL library supports multiple implementations of its functions.
                    Extension functions supported in one rendering context are not necessarily
                    available in a separate rendering context.  Thus, for a given rendering
                    context in an application, use the function addresses returned by the
                    <b>wglGetProcAddress</b> function only.
                </para>
                <para>
                    The spelling and the case of the extension function pointed to by
                    <i>extension</i> must be identical to that of a function supported and
                    implemented by OpenGL.  Because extension functions are not exported by
                    OpenGL, you must use <b>wglGetProcAddress</b> to get the addresses of
                    vendor-specific extension functions.
                </para>
                <para>
                    The extension function addresses are unique for each pixel format.  All
                    rendering contexts of a given pixel format share the same extension function
                    addresses.
                </para>
            </remarks>
            <seealso cref="M:Tao.OpenGl.Gl.glGetString(System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)">
            <summary>
                <para>
                    The <b>wglMakeCurrent</b> function makes a specified OpenGL rendering context
                    the calling thread's current rendering context.  All subsequent OpenGL calls
                    made by the thread are drawn on the device identified by <i>deviceContext</i>.
                    You can also use <b>wglMakeCurrent</b> to change the calling thread's current
                    rendering context so it's no longer current.
                </para>
            </summary>
            <param name="deviceContext">
                <para>
                    Handle to a device context.  Subsequent OpenGL calls made by the calling
                    thread are drawn on the device identified by <i>deviceContext</i>.
                </para>
            </param>
            <param name="renderingContext">
                <para>
                    Handle to an OpenGL rendering context that the function sets as the calling
                    thread's rendering context.
                </para>
                <para>
                    If <i>rendingContext</i> is <see cref="F:System.IntPtr.Zero"/>, the function makes
                    the calling thread's current rendering context no longer current, and
                    releases the device context that is used by the rendering context.  In this
                    case, <i>deviceContext</i> is ignored.
                </para>
            </param>
            <returns>
                <para>
                    When the <b>wglMakeCurrent</b> function succeeds, the return value is true;
                    otherwise the return value is false.  To get extended error information,
                    call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The <i>deviceContext</i> parameter must refer to a drawing surface supported
                    by OpenGL.  It need not be the same <i>deviceContext</i> that was passed to
                    <see cref="M:Tao.Platform.Windows.Wgl.wglCreateContext(System.IntPtr)"/> when <i>renderingContext</i> was created, but
                    it must be on the same device and have the same pixel format.  GDI
                    transformation and clipping in <i>deviceContext</i> are not supported by the
                    rendering context.  The current rendering context uses the
                    <i>deviceContext</i> device context until the rendering context is no longer
                    current.
                </para>
                <para>
                    Before switching to the new rendering context, OpenGL flushes any previous
                    rendering context that was current to the calling thread.
                </para>
                <para>
                    A thread can have one current rendering context.  A process can have multiple
                    rendering contexts by means of multithreading.  A thread must set a current
                    rendering context before calling any OpenGL functions.  Otherwise, all OpenGL
                    calls are ignored.
                </para>
                <para>
                    A rendering context can be current to only one thread at a time.  You cannot
                    make a rendering context current to multiple threads.
                </para>
                <para>
                    An application can perform multithread drawing by making different rendering
                    contexts current to different threads, supplying each thread with its own
                    rendering context and device context.
                </para>
                <para>
                    If an error occurs, the <b>wglMakeCurrent</b> function makes the thread's
                    current rendering context not current before returning.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglCreateContext(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglDeleteContext(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglGetCurrentContext"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglGetCurrentDC"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglRealizeLayerPalette(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
                <para>
                    The <b>wglRealizeLayerPalette</b> function maps palette entries from a given
                    color-index layer plane into the physical palette or initializes the palette
                    of an RGBA layer plane.
                </para>
            </summary>
            <param name="deviceContext">
                <para>
                    Specifies the device context of a window whose layer plane palette is to be
                    realized into the physical palette.
                </para>
            </param>
            <param name="layerPlane">
                <para>
                    Specifies the overlay or underlay plane.  Positive values of
                    <i>layerPlane</i> identify overlay planes, where 1 is the first overlay plane
                    over the main plane, 2 is the second overlay plane over the first overlay
                    plane, and so on.  Negative values identify underlay planes, where 1 is the
                    first underlay plane under the main plane, 2 is the second underlay plane
                    under the first underlay plane, and so on.  The number of overlay and
                    underlay planes is given in the <b>bReserved</b> member of the
                    <see cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/> structure.
                </para>
            </param>
            <param name="realize">
                <para>
                    Indicates whether the palette is to be realized into the physical palette.
                    When <i>realize</i> is true, the palette entries are mapped into the physical
                    palette where available.  When <i>realize</i> is false, the palette entries
                    for the layer plane of the window are no longer needed and might be released
                    for use by another foreground window.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true, even if <i>realize</i> is
                    true and the physical palette is not available.  If the function fails or
                    when no pixel format is selected, the return value is false.  To get extended
                    error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The physical palette for a layer plane is a shared resource among windows
                    with layer planes.  When more than one window attempts to realize a palette
                    for a given physical layer plane, only one palette at a time is realized.
                    When you call the <b>wglRealizeLayerPalette</b> function, the layer palette
                    of a foreground window is always realized first.
                </para>
                <para>
                    When a window's layer palette is realized, its palette entries are always
                    mapped one-to-one into the physical palette.  Unlike GDI logical palettes,
                    with <b>wglRealizeLayerPalette</b> there is no mapping of other windows'
                    layer palettes to the current physical palette.
                </para>
                <para>
                    Whenever a window becomes the foreground window, call
                    <b>wglRealizeLayerPalette</b> to realize its layer palettes again, even if
                    the pixel type of the layer plane is RGBA.
                </para>
                <para>
                    Because <b>wglRealizeLayerPalette</b> doesn't realize the palette of the
                    main plane, use GDI palette functions to realize the main plane palette.
                </para>
            </remarks>
            <seealso cref="!:Gdi.LAYERPLANEDESCRIPTOR"/>
            <seealso cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/>
            <seealso cref="!:wglDescribeLayerPlane"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglGetLayerPaletteEntries(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[])"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglSetLayerPaletteEntries(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[])"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetLayerPaletteEntries(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>
                <para>
                    The <b>wglSetLayerPaletteEntries</b> function sets the palette entries in a
                    given color-index layer plane for a specified device context.
                </para>
            </summary>
            <param name="deviceContext">
                <para>
                    Specifies the device context of a window whose layer palette is to be set.
                </para>
            </param>
            <param name="layerPlane">
                <para>
                    Specifies an overlay or underlay plane.  Positive values of <i>layerPlane</i>
                    identify overlay planes, where 1 is the first overlay plane over the main
                    plane, 2 is the second overlay plane over the first overlay plane, and so on.
                    Negative values identify underlay planes, where 1 is the first underlay
                    plane under the main plane, 2 is the second underlay plane under the first
                    underlay plane, and so on.  The number of overlay and underlay planes is
                    given in the <b>bReserved</b> member of the
                    <see cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/> structure.
                </para>
            </param>
            <param name="start">
                <para>
                    Specifies the first palette entry to be set.
                </para>
            </param>
            <param name="entries">
                <para>
                    Specifies the number of palette entries to be set.
                </para>
            </param>
            <param name="colors">
                <para>
                    Points to an array of <see cref="T:System.Int32"/>'s that contain palette RGB color
                    values.  The array must contain at least as many structures as specified by
                    <i>entries</i>.
                </para>
                <para>
                    The color values should be a RGB value as an int in the hexidecimal form
                    of 0x00bbggrr.  The low-order byte contains a value for the relative
                    intensity of red; the second byte contains a value for green; and the third
                    byte contains a value for blue.  The high-order byte must be zero.  The
                    maximum value for a single byte is 0xFF.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the number of entries that were
                    set in the palette in the specified layer plane of the window.  If the
                    function fails or no pixel format is selected, the return value is zero.  To
                    get extended error information, call
                    <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    Each color-index plane in a window has a palette with a size 2^n, where n is
                    the number of bit planes in the layer plane.  You cannot modify the
                    transparent index of a palette.
                </para>
                <para>
                    Use the <see cref="M:Tao.Platform.Windows.Wgl.wglRealizeLayerPalette(System.IntPtr,System.Int32,System.Boolean)"/> function to realize the layer
                    palette.  Initially the layer palette contains only entries for white.
                </para>
                <para>
                    The <b>wglSetLayerPaletteEntries</b> function doesn't set the palette entries
                    of the main plane palette.  To update the main plane palette, use GDI palette
                    functions.
                </para>
            </remarks>
            <seealso cref="!:Gdi.LAYERPLANEDESCRIPTOR"/>
            <seealso cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/>
            <seealso cref="!:wglDescribeLayerPlane"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglGetLayerPaletteEntries(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[])"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglRealizeLayerPalette(System.IntPtr,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglShareLists(System.IntPtr,System.IntPtr)">
            <summary>
                <para>
                    The <b>wglShareLists</b> function enables multiple OpenGL rendering contexts
                    to share a single display-list space.
                </para>
            </summary>
            <param name="source">
                <para>
                    Specifies the OpenGL rendering context with which to share display lists.
                </para>
            </param>
            <param name="destination">
                <para>
                    Specifies the OpenGL rendering context to share display lists with
                    <i>source</i>.  The <i>destination</i> parameter should not contain any
                    existing display lists when <b>wglShareLists</b> is called.
                </para>
            </param>
            <returns>
                <para>
                    When the function succeeds, the return value is true.
                </para>
                <para>
                    When the function fails, the return value is false and the display lists are
                    not shared.  To get extended error information, call
                    <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    When you create an OpenGL rendering context, it has its own display-list
                    space.  The <b>wglShareLists</b> function enables a rendering context to
                    share the display-list space of another rendering context; any number of
                    rendering contexts can share a single display-list space.  Once a rendering
                    context shares a display-list space, the rendering context always uses the
                    display-list space until the rendering context is deleted.  When the last
                    rendering context of a shared display-list space is deleted, the shared
                    display-list space is deleted.  All the indexes and definitions of display
                    lists in a shared display-list space are shared.
                </para>
                <para>
                    You can only share display lists with rendering contexts within the same
                    process.  However, not all rendering contexts in a process can share display
                    lists.  Rendering contexts can share display lists only if they use the same
                    implementation of OpenGL functions.  All client rendering contexts of a given
                    pixel format can always share display lists.
                </para>
                <para>
                    All rendering contexts of a shared display list must use an identical pixel
                    format.  Otherwise the results depend on the implementation of OpenGL used.
                </para>
                <para>
                    <b>NOTE</b>
                </para>
                <para>
                    The <b>wglShareLists</b> function is only available with OpenGL version 1.01
                    or later.  To determine the version number of the implementation of OpenGL,
                    call <see cref="M:Tao.OpenGl.Gl.glGetString(System.Int32)"/>.
                </para>
            </remarks>
            <seealso cref="M:Tao.OpenGl.Gl.glGetString(System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSwapLayerBuffers(System.IntPtr,System.Int32)">
            <summary>
                <para>
                    The <b>wglSwapLayerBuffers</b> function swaps the front and back buffers in
                    the overlay, underlay, and main planes of the window referenced by a
                    specified device context.
                </para>
            </summary>
            <param name="deviceContext">
                <para>
                    Specifies the device context of a window whose layer plane palette is to be
                    realized into the physical palette.
                </para>
            </param>
            <param name="planes">
                <para>
                    Specifies the overlay, underlay, and main planes whose front and back buffers
                    are to be swapped.  The <b>bReserved</b> member of the
                    <see cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/> structure specifies the number of
                    overlay and underlay planes.  The <i>planes</i> parameter is a bitwise
                    combination of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Meaning</description>
                        </listheader>
                        <item>
                            <term>WGL_SWAP_MAIN_PLANE</term>
                            <description>
                                Swaps the front and back buffers of the main plane.
                            </description>
                        </item>
                        <item>
                            <term>WGL_SWAP_OVERLAYi</term>
                            <description>
                                Swaps the front and back buffers of the overlay plane i, where
                                i is an integer between 1 and 15.  WGL_SWAP_OVERLAY1 identifies
                                the first overlay plane over the main plane, WGL_SWAP_OVERLAY2
                                identifies the second overlay plane over the first overlay plane,
                                and so on.
                            </description>
                        </item>
                        <item>
                            <term>WGL_SWAP_UNDERLAYi</term>
                            <description>
                                Swaps the front and back buffers of the underlay plane i, where i
                                is an integer between 1 and 15.  WGL_SWAP_UNDERLAY1 identifies
                                the first underlay plane under the main plane, WGL_SWAP_UNDERLAY2
                                identifies the second underlay plane under the first underlay
                                plane, and so on.
                            </description>
                        </item>
                    </list>
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.  If the function fails,
                    the return value is false.  To get extended error information, call
                    <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    When a layer plane doesn't include a back buffer, calling the
                    <b>wglSwapLayerBuffers</b> function has no effect on that layer plane.  After
                    you call <b>wglSwapLayerBuffers</b>, the state of the back buffer content is
                    given in the corresponding /* <see cref="!:Gdi.LAYERPLANEDESCRIPTOR"/> */ structure
                    of the layer plane or in the <see cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/>
                    structure of the main plane.  The <b>wglSwapLayerBuffers</b> function swaps
                    the front and back buffers in the specified layer planes simultaneously.
                </para>
                <para>
                    Some devices don't support swapping layer planes individually; they swap all
                    layer planes as a group.  When the <b>PFD_SWAP_LAYER_BUFFERS</b> flag of the
                    <see cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/> structure is set, it indicates that
                    a device can swap individual layer planes and that you can call
                    <b>wglSwapLayerBuffers</b>.
                </para>
                <para>
                    With applications that use multiple threads, before calling
                    <b>wglSwapLayerBuffers</b>, clear all drawing commands in all threads drawing
                    to the same window.
                </para>
            </remarks>
            /* <seealso cref="!:Gdi.LAYERPLANEDESCRIPTOR"/>*/
            <seealso cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/>
            <seealso cref="M:Tao.Platform.Windows.Gdi.SwapBuffers(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglUseFontBitmaps(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>
                    The <b>wglUseFontBitmaps</b> function creates a set of bitmap display lists
                    for use in the current OpenGL rendering context.  The set of bitmap display
                    lists is based on the glyphs in the currently selected font in the device
                    context.  You can then use bitmaps to draw characters in an OpenGL image.
                </para>
                <para>
                    The <b>wglUseFontBitmaps</b> function creates <i>count</i> display lists,
                    one for each of a run of <i>count</i> glyphs that begins with the
                    <i>first</i> glyph in the <i>deviceContext</i> parameter's selected fonts.
                </para>
            </summary>
            <param name="deviceContext">
                <para>
                    Specifies the device context whose currently selected font will be used to
                    form the glyph bitmap display lists in the current OpenGL rendering context.
                </para>
            </param>
            <param name="first">
                <para>
                    Specifies the first glyph in the run of glyphs that will be used to form
                    glyph bitmap display lists.
                </para>
            </param>
            <param name="count">
                <para>
                    Specifies the number of glyphs in the run of glyphs that will be used to
                    form glyph bitmap display lists.  The function creates <i>count</i> display
                    lists, one for each glyph in the run.
                </para>
            </param>
            <param name="listBase">
                <para>
                    Specifies a starting display list.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The <b>wglUseFontBitmaps</b> function defines <i>count</i> display lists in
                    the current OpenGL rendering context.  Each display list has an identifying
                    number, starting at <i>listBase</i>.  Each display list consists of a single
                    call to <see cref="M:Tao.OpenGl.Gl.glBitmap(System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Byte@)"/>.  The definition of bitmap
                    <i>listBase + i</i> is taken from the glyph <i>first + i</i> of the font
                    currently selected in the device context specified by <i>deviceContext</i>.
                    If a glyph is not defined, then the function defines an empty display list
                    for it.
                </para>
                <para>
                    The <b>wglUseFontBitmaps</b> function creates bitmap text in the plane of the
                    screen.  It enables the labeling of objects in OpenGL.
                </para>
                <para>
                    In the current version of Microsoft's implementation of OpenGL in Windows NT
                    and Windows 95, you cannot make GDI calls to a device context that has a
                    double-buffered pixel format.  Therefore, you cannot use the GDI fonts and
                    text functions with such device contexts.  You can use the
                    <b>wglUseFontBitmaps</b> function to circumvent this limitation and draw text
                    in a double-buffered device context.
                </para>
                <para>
                    The function determines the parameters of each call to
                    <see cref="M:Tao.OpenGl.Gl.glBitmap(System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Byte@)"/> as follows:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>glBitmap Parameter</term>
                            <description>Meaning</description>
                        </listheader>
                        <item>
                            <term>width</term>
                            <description>
                                The width of the glyph's bitmap, as returned in the
                                <b>gmBlackBoxX</b> member of the glyph's
                             /*   <see cref="!:Gdi.GLYPHMETRICS"/> */structure.
                            </description>
                        </item>
                        <item>
                            <term>height</term>
                            <description>
                                The height of the glyph's bitmap, as returned in the
                                <b>gmBlackBoxY</b> member of the glyph's
                            /*    <see cref="!:Gdi.GLYPHMETRICS"/> */structure.
                            </description>
                        </item>
                        <item>
                            <term>xorig</term>
                            <description>
                                The x offset of the glyph's origin, as returned in the
                                <b>gmptGlyphOrigin.x</b> member of the glyph's
                               /* <see cref="!:Gdi.GLYPHMETRICS"/> */ structure.
                            </description>
                        </item>
                        <item>
                            <term>yorig</term>
                            <description>
                                The y offset of the glyph's origin, as returned in the
                                <b>gmptGlyphOrigin.y</b> member of the glyph's
                                /* <see cref="!:Gdi.GLYPHMETRICS"/> */structure.
                            </description>
                        </item>
                        <item>
                            <term>xmove</term>
                            <description>
                                The horizontal distance to the origin of the next character cell,
                                as returned in the <b>gmCellIncX</b> member of the glyph's
                               /* <see cref="!:Gdi.GLYPHMETRICS"/> */structure.
                            </description>
                        </item>
                        <item>
                            <term>ymove</term>
                            <description>
                                The vertical distance to the origin of the next character cell as
                                returned in the <b>gmCellIncY</b> member of the glyph's
                                /* <see cref="!:Gdi.GLYPHMETRICS"/> */structure.
                            </description>
                        </item>
                        <item>
                            <term>bitmap</term>
                            <description>
                                The bitmap for the glyph, as returned by
                               /* <see cref="!:Gdi.GetGlyphOutline"/>*/  with <i>uFormat</i> equal to 1.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    The following code example shows how to use <b>wglUseFontBitmaps</b> to draw
                    some text:
                </para>
                <para>
                    <code>
                        IntPtr hdc;
                        IntPtr hglrc;
                                    // create a rendering context
                        hglrc = Wgl.wglCreateContext(hdc);
                                    // make it the calling thread's current rendering context
                        Wgl.wglMakeCurrent(hdc, hglrc);
                                    // now we can call OpenGL API
                                    // make the system font the device context's selected font
                        Gdi.SelectObject(hdc, Gdi.GetStockObject(SYSTEM_FONT));
                                    // create the bitmap display lists
                        // we're making images of glyphs 0 thru 255
                        // the display list numbering starts at 1000, an arbitrary choice
                        Wgl.wglUseFontBitmaps(hdc, 0, 255, 1000);
                                    // display a string:
                        // indicate start of glyph display lists
                        GL.glListBase(1000);
                                    z/ now draw the characters in a string
                        GL.glCallLists(24, GL.GL_UNSIGNED_SHORT, "Hello Win32 OpenGL World");
                    </code>
                </para>
            </remarks>
            /* <seealso cref="!:Gdi.GetGlyphOutline"/>*/
            <seealso cref="M:Tao.OpenGl.Gl.glBitmap(System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Byte@)"/>
            <seealso cref="M:Tao.OpenGl.Gl.glCallLists(System.Int32,System.Int32,System.Boolean[])"/>
            <seealso cref="M:Tao.OpenGl.Gl.glListBase(System.Int32)"/>
            /* <seealso cref="!:Gdi.GLYPHMETRICS"/>*/
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglUseFontOutlines(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT[])"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglUseFontOutlines(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT[])">
            <summary>
                <para>
                    The <b>wglUseFontOutlines</b> function creates a set of display lists, one
                    for each glyph of the currently selected outline font of a device context,
                    for use with the current rendering context.  The display lists are used to
                    draw 3-D characters of TrueType fonts.  Each display list describes a glyph
                    outline in floating-point coordinates.
                </para>
                <para>
                    The run of glyphs begins with the <i>first</i> glyph of the font of the
                    specified device context.  The em square size of the font, the notional grid
                    size of the original font outline from which the font is fitted, is mapped to
                    1.0 in the x- and y-coordinates in the display lists.  The <i>extrusion</i>
                    parameter sets how much depth the font has in the z direction.
                </para>
                <para>
                    The <i>glyphMetrics</i> parameter returns a
                    <see cref="T:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT"/> structure that contains information
                    about the placement and orientation of each glyph in a character cell.
                </para>
            </summary>
            <param name="deviceContext">
                <para>
                    Specifies the device context with the desired outline font.  The outline font
                    of <i>deviceContext</i> is used to create the display lists in the current
                    rendering context.
                </para>
            </param>
            <param name="first">
                <para>
                    Specifies the first of the set of glyphs that form the font outline display
                    lists.
                </para>
            </param>
            <param name="count">
                <para>
                    Specifies the number of glyphs in the set of glyphs used to form the font
                    outline display lists.  The <b>wglUseFontOutlines</b> function creates
                    <i>count</i> display lists, one display list for each glyph in a set of
                    glyphs.
                </para>
            </param>
            <param name="listBase">
                <para>
                    Specifies a starting display list.
                </para>
            </param>
            <param name="deviation">
                <para>
                    Specifies the maximum chordal deviation from the original outlines.  When
                    <i>deviation</i> is zero, the chordal deviation is equivalent to one design
                    unit of the original font.  The value of <i>deviation</i> must be equal to
                    or greater than 0.
                </para>
            </param>
            <param name="extrusion">
                <para>
                    Specifies how much a font is extruded in the negative z direction.  The
                    value must be equal to or greater than 0.  When <i>extrusion</i> is 0, the
                    display lists are not extruded.
                </para>
            </param>
            <param name="format">
                <para>
                    Specifies the format, either <see cref="F:Tao.Platform.Windows.Wgl.WGL_FONT_LINES"/> or
                    <see cref="F:Tao.Platform.Windows.Wgl.WGL_FONT_POLYGONS"/>, to use in the display lists.  When
                    <i>format</i> is <see cref="F:Tao.Platform.Windows.Wgl.WGL_FONT_LINES"/>, the
                    <b>wglUseFontOutlines</b> function creates fonts with line segments.  When
                    <i>format</i> is <see cref="F:Tao.Platform.Windows.Wgl.WGL_FONT_POLYGONS"/>, <b>wglUseFontOutlines</b>
                    creates fonts with polygons.
                </para>
            </param>
            <param name="glyphMetrics">
                <para>
                    Points to an array of <i>count</i> <see cref="T:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT"/>
                    structures that is to receive the metrics of the glyphs.  When
                    <i>glyphMetrics</i> is null, no glyph metrics are returned.
                </para>
            </param>
            <returns>
                <para>
                    When the function succeeds, the return value is true.
                </para>
                <para>
                    When the function fails, the return value is false and no display lists are
                    generated.  To get extended error information, call
                    <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The <b>wglUseFontOutlines</b> function defines the glyphs of an outline font
                    with display lists in the current rendering context.  The
                    <b>wglUseFontOutlines</b> function works with TrueType fonts only; stroke and
                    raster fonts are not supported.
                </para>
                <para>
                    Each display list consists of either line segments or polygons, and has a
                    unique identifying number starting with the <i>listBase</i> number.
                </para>
                <para>
                    The <b>wglUseFontOutlines</b> function approximates glyph outlines by
                    subdividing the quadratic B-spline curves of the outline into line segments,
                    until the distance between the outline and the interpolated midpoint is
                    within the value specified by <i>deviation</i>.  This is the final format
                    used when <i>format</i> is <see cref="F:Tao.Platform.Windows.Wgl.WGL_FONT_LINES"/>.  When you specify
                    <see cref="F:Tao.Platform.Windows.Wgl.WGL_FONT_LINES"/>, the display lists created don't contain any
                    normals; thus lighting doesn't work properly.  To get the correct lighting of
                    lines use <see cref="F:Tao.Platform.Windows.Wgl.WGL_FONT_POLYGONS"/> and set
                    <c>Gl.glPolygonMode(Gl.GL_FRONT, Gl.GL_LINE)</c>.  When you specify
                    <i>format</i> as <see cref="F:Tao.Platform.Windows.Wgl.WGL_FONT_POLYGONS"/> the outlines are further
                    tessellated into separate triangles, triangle fans, triangle strips, or
                    quadrilateral strips to create the surface of each glyph.  With
                    <see cref="F:Tao.Platform.Windows.Wgl.WGL_FONT_POLYGONS"/>, the created display lists call
                    <c>Gl.glFrontFace(Gl.GL_CW)</c> or <c>Gl.glFrontFace(Gl.GL_CCW)</c>; thus
                    the current front-face value might be altered.  For the best appearance of
                    text with <see cref="F:Tao.Platform.Windows.Wgl.WGL_FONT_POLYGONS"/>, cull the back faces as follows:
                </para>
                <para>
                    <code>
                        Gl.glCullFace(Gl.GL_BACK);
                        Gl.glEnable(Gl.GL_CULL_FACE);
                    </code>
                </para>
                <para>
                    A <see cref="T:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT"/> structure contains information about
                    the placement and orientation of each glyph in a character cell.  The
                    <i>glyphMetrics</i> parameter is an array of
                    <see cref="T:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT"/> structures holding the entire set of
                    glyphs for a font.  Each display list ends with a translation specified with
                    the <b>gmfCellIncX</b> and <b>gmfCellIncY</b> members of the corresponding
                    <see cref="T:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT"/> structure.  The translation enables the
                    drawing of successive characters in their natural direction with a single
                    call to <see cref="M:Tao.OpenGl.Gl.glCallLists(System.Int32,System.Int32,System.Boolean[])"/>.
                </para>
                <para>
                    <b>NOTE</b>
                </para>
                <para>
                    With the current release of OpenGL for Windows NT and Windows 95, you cannot
                    make GDI calls to a device context when a pixel format is double-buffered.
                    You can work around this limitation by using <b>wglUseFontOutlines</b> and
                    <see cref="M:Tao.Platform.Windows.Wgl.wglUseFontBitmaps(System.IntPtr,System.Int32,System.Int32,System.Int32)"/>, when using double-buffered device contexts.
                </para>
                <para>
                    The following code example shows how to draw text using
                    <b>wglUseFontOutlines</b>:
                </para>
                <para>
                    <code>
                        IntPtr hdc;  // A TrueType font has already been selected
                        IntPtr hglrc;
                        Gdi.GLYPHMETRICSFLOAT[] agmf = new Gdi.GLYPHMETRICSFLOAT[256];
                                    // Make hglrc the calling thread's current rendering context
                        Wgl.wglMakeCurrent(hdc, hglrc);
                                    // create display lists for glyphs 0 through 255 with 0.1 extrusion
                        // and default deviation. The display list numbering starts at 1000
                        // (it could be any number)
                        Wgl.wglUseFontOutlines(hdc, 0, 255, 1000, 0.0f, 0.1f, Wgl.WGL_FONT_POLYGONS, ref agmf);
                                    // Set up transformation to draw the string
                        Gl.glLoadIdentity();
                        Gl.glTranslate(0.0f, 0.0f, -5.0f)
                        Gl.glScalef(2.0f, 2.0f, 2.0f);
                                    // Display a string
                        Gl.glListBase(1000); // Indicates the start of display lists for the glyphs
                                    // Draw the characters in a string
                        Gl.glCallLists(24, Gl.GL_UNSIGNED_SHORT, "Hello Win32 OpenGL World.");
                    </code>
                </para>
            </remarks>
            <seealso cref="T:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT"/>
            <seealso cref="M:Tao.OpenGl.Gl.glCallLists(System.Int32,System.Int32,System.Boolean[])"/>
            <seealso cref="M:Tao.OpenGl.Gl.glListBase(System.Int32)"/>
            <seealso cref="M:Tao.OpenGl.Gl.glTexGenf(System.Int32,System.Int32,System.Single)"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglUseFontBitmaps(System.IntPtr,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreateBufferRegionARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iLayerPlane"></param>
            <param name="uType"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreateBufferRegionARB(System.IntPtr,System.IntPtr,System.Int32,System.UInt32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iLayerPlane"></param>
            <param name="uType"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglDeleteBufferRegionARB(System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hRegion"></param>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSaveBufferRegionARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hRegion"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglRestoreBufferRegionARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hRegion"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="xSrc"></param>
            <param name="ySrc"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetExtensionsStringARB(System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Int32[],System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Int32*,System.Int32*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[],System.Single[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@,System.Single@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Int32@,System.Single@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Int32[],System.Single[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Int32*,System.Single*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatARB(System.IntPtr,System.IntPtr,System.Int32[],System.Single[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatARB(System.IntPtr,System.IntPtr,System.Int32@,System.Single@,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatARB(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatARB(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatARB(System.IntPtr,System.IntPtr,System.Int32@,System.Single@,System.UInt32,System.Int32@,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatARB(System.IntPtr,System.IntPtr,System.Int32[],System.Single[],System.UInt32,System.Int32[],System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatARB(System.IntPtr,System.IntPtr,System.Int32*,System.Single*,System.UInt32,System.Int32*,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglMakeContextCurrentARB(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDrawDC"></param>
            <param name="hReadDC"></param>
            <param name="hglrc"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetCurrentReadDCARB(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreatePbufferARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iPixelFormat"></param>
            <param name="iWidth"></param>
            <param name="iHeight"></param>
            <param name="piAttribList"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreatePbufferARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iPixelFormat"></param>
            <param name="iWidth"></param>
            <param name="iHeight"></param>
            <param name="piAttribList"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreatePbufferARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iPixelFormat"></param>
            <param name="iWidth"></param>
            <param name="iHeight"></param>
            <param name="piAttribList"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreatePbufferARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iPixelFormat"></param>
            <param name="iWidth"></param>
            <param name="iHeight"></param>
            <param name="piAttribList"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPbufferDCARB(System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglReleasePbufferDCARB(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="hDC"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglDestroyPbufferARB(System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglQueryPbufferARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglQueryPbufferARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglQueryPbufferARB(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglQueryPbufferARB(System.IntPtr,System.IntPtr,System.Int32,System.Int32*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglBindTexImageARB(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="iBuffer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglReleaseTexImageARB(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="iBuffer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetPbufferAttribARB(System.IntPtr,System.IntPtr,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="piAttribList"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetPbufferAttribARB(System.IntPtr,System.IntPtr,System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="piAttribList"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetPbufferAttribARB(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="piAttribList"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetPbufferAttribARB(System.IntPtr,System.IntPtr,System.Int32*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="piAttribList"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetExtensionsStringEXT(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglMakeContextCurrentEXT(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDrawDC"></param>
            <param name="hReadDC"></param>
            <param name="hglrc"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetCurrentReadDCEXT(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Int32[],System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribivEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Int32*,System.Int32*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="piValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[],System.Single[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@,System.Single@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Int32@,System.Single@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Int32[],System.Single[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPixelFormatAttribfvEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Int32*,System.Single*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="iPixelFormat"></param>
            <param name="iLayerPlane"></param>
            <param name="nAttributes"></param>
            <param name="piAttributes"></param>
            <param name="pfValues"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatEXT(System.IntPtr,System.IntPtr,System.Int32[],System.Single[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatEXT(System.IntPtr,System.IntPtr,System.Int32@,System.Single@,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatEXT(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatEXT(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatEXT(System.IntPtr,System.IntPtr,System.Int32@,System.Single@,System.UInt32,System.Int32@,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatEXT(System.IntPtr,System.IntPtr,System.Int32[],System.Single[],System.UInt32,System.Int32[],System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglChoosePixelFormatEXT(System.IntPtr,System.IntPtr,System.Int32*,System.Single*,System.UInt32,System.Int32*,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="piAttribIList"></param>
            <param name="pfAttribFList"></param>
            <param name="nMaxFormats"></param>
            <param name="piFormats"></param>
            <param name="nNumFormats"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSwapIntervalEXT(System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetSwapIntervalEXT(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreatePbufferEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iPixelFormat"></param>
            <param name="iWidth"></param>
            <param name="iHeight"></param>
            <param name="piAttribList"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreatePbufferEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iPixelFormat"></param>
            <param name="iWidth"></param>
            <param name="iHeight"></param>
            <param name="piAttribList"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreatePbufferEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iPixelFormat"></param>
            <param name="iWidth"></param>
            <param name="iHeight"></param>
            <param name="piAttribList"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreatePbufferEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iPixelFormat"></param>
            <param name="iWidth"></param>
            <param name="iHeight"></param>
            <param name="piAttribList"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetPbufferDCEXT(System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglReleasePbufferDCEXT(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="hDC"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglDestroyPbufferEXT(System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglQueryPbufferEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglQueryPbufferEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglQueryPbufferEXT(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglQueryPbufferEXT(System.IntPtr,System.IntPtr,System.Int32,System.Int32*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hPbuffer"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetDigitalVideoParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetDigitalVideoParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetDigitalVideoParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetDigitalVideoParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetDigitalVideoParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetDigitalVideoParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetDigitalVideoParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetDigitalVideoParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGammaTableParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGammaTableParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGammaTableParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGammaTableParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetGammaTableParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetGammaTableParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetGammaTableParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetGammaTableParametersI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iAttribute"></param>
            <param name="piValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGammaTableI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int16[],System.Int16[],System.Int16[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iEntries"></param>
            <param name="puRed"></param>
            <param name="puGreen"></param>
            <param name="puBlue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGammaTableI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int16@,System.Int16@,System.Int16@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iEntries"></param>
            <param name="puRed"></param>
            <param name="puGreen"></param>
            <param name="puBlue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGammaTableI3D(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iEntries"></param>
            <param name="puRed"></param>
            <param name="puGreen"></param>
            <param name="puBlue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGammaTableI3D(System.IntPtr,System.IntPtr,System.Int32,System.UInt16@,System.UInt16@,System.UInt16@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iEntries"></param>
            <param name="puRed"></param>
            <param name="puGreen"></param>
            <param name="puBlue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGammaTableI3D(System.IntPtr,System.IntPtr,System.Int32,System.UInt16[],System.UInt16[],System.UInt16[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iEntries"></param>
            <param name="puRed"></param>
            <param name="puGreen"></param>
            <param name="puBlue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGammaTableI3D(System.IntPtr,System.IntPtr,System.Int32,System.UInt16*,System.UInt16*,System.UInt16*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iEntries"></param>
            <param name="puRed"></param>
            <param name="puGreen"></param>
            <param name="puBlue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetGammaTableI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int16[],System.Int16[],System.Int16[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iEntries"></param>
            <param name="puRed"></param>
            <param name="puGreen"></param>
            <param name="puBlue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetGammaTableI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int16@,System.Int16@,System.Int16@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iEntries"></param>
            <param name="puRed"></param>
            <param name="puGreen"></param>
            <param name="puBlue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetGammaTableI3D(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iEntries"></param>
            <param name="puRed"></param>
            <param name="puGreen"></param>
            <param name="puBlue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetGammaTableI3D(System.IntPtr,System.IntPtr,System.Int32,System.UInt16@,System.UInt16@,System.UInt16@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iEntries"></param>
            <param name="puRed"></param>
            <param name="puGreen"></param>
            <param name="puBlue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetGammaTableI3D(System.IntPtr,System.IntPtr,System.Int32,System.UInt16[],System.UInt16[],System.UInt16[])">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iEntries"></param>
            <param name="puRed"></param>
            <param name="puGreen"></param>
            <param name="puBlue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSetGammaTableI3D(System.IntPtr,System.IntPtr,System.Int32,System.UInt16*,System.UInt16*,System.UInt16*)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="iEntries"></param>
            <param name="puRed"></param>
            <param name="puGreen"></param>
            <param name="puBlue"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglEnableGenlockI3D(System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglDisableGenlockI3D(System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglIsEnabledGenlockI3D(System.IntPtr,System.IntPtr,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="pFlag"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGenlockSourceI3D(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uSource"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGenlockSourceI3D(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uSource"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGenlockSourceI3D(System.IntPtr,System.IntPtr,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uSource"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGenlockSourceI3D(System.IntPtr,System.IntPtr,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uSource"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGenlockSourceEdgeI3D(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uEdge"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGenlockSourceEdgeI3D(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uEdge"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGenlockSourceEdgeI3D(System.IntPtr,System.IntPtr,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uEdge"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGenlockSourceEdgeI3D(System.IntPtr,System.IntPtr,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uEdge"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGenlockSampleRateI3D(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uRate"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGenlockSampleRateI3D(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uRate"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGenlockSampleRateI3D(System.IntPtr,System.IntPtr,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uRate"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGenlockSampleRateI3D(System.IntPtr,System.IntPtr,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uRate"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGenlockSourceDelayI3D(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uDelay"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGenlockSourceDelayI3D(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uDelay"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGenlockSourceDelayI3D(System.IntPtr,System.IntPtr,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uDelay"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetGenlockSourceDelayI3D(System.IntPtr,System.IntPtr,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uDelay"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglQueryGenlockMaxSourceDelayI3D(System.IntPtr,System.IntPtr,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uMaxLineDelay"></param>
            <param name="uMaxPixelDelay"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglQueryGenlockMaxSourceDelayI3D(System.IntPtr,System.IntPtr,System.UInt32@,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="uMaxLineDelay"></param>
            <param name="uMaxPixelDelay"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreateImageBufferI3D(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="dwSize"></param>
            <param name="uFlags"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglCreateImageBufferI3D(System.IntPtr,System.IntPtr,System.Int32,System.UInt32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="dwSize"></param>
            <param name="uFlags"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglDestroyImageBufferI3D(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hDC"></param>
            <param name="pAddress"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglAssociateImageBufferEventsI3D(System.IntPtr,System.IntPtr,System.IntPtr[],System.IntPtr[],System.Int32[],System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="pEvent"></param>
            <param name="pAddress"></param>
            <param name="pSize"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglAssociateImageBufferEventsI3D(System.IntPtr,System.IntPtr,System.IntPtr[],System.IntPtr[],System.Int32@,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="pEvent"></param>
            <param name="pAddress"></param>
            <param name="pSize"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglAssociateImageBufferEventsI3D(System.IntPtr,System.IntPtr,System.IntPtr[],System.IntPtr[],System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="pEvent"></param>
            <param name="pAddress"></param>
            <param name="pSize"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglAssociateImageBufferEventsI3D(System.IntPtr,System.IntPtr,System.IntPtr[],System.IntPtr[],System.IntPtr,System.UInt32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="pEvent"></param>
            <param name="pAddress"></param>
            <param name="pSize"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglAssociateImageBufferEventsI3D(System.IntPtr,System.IntPtr,System.IntPtr[],System.IntPtr[],System.Int32@,System.UInt32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="pEvent"></param>
            <param name="pAddress"></param>
            <param name="pSize"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglAssociateImageBufferEventsI3D(System.IntPtr,System.IntPtr,System.IntPtr[],System.IntPtr[],System.Int32[],System.UInt32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="pEvent"></param>
            <param name="pAddress"></param>
            <param name="pSize"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglAssociateImageBufferEventsI3D(System.IntPtr,System.IntPtr,System.IntPtr[],System.IntPtr[],System.Int32*,System.UInt32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="pEvent"></param>
            <param name="pAddress"></param>
            <param name="pSize"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglReleaseImageBufferEventsI3D(System.IntPtr,System.IntPtr,System.IntPtr[],System.Int32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="pAddress"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglReleaseImageBufferEventsI3D(System.IntPtr,System.IntPtr,System.IntPtr[],System.UInt32)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="hdc"></param>
            <param name="pAddress"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglEnableFrameLockI3D(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglDisableFrameLockI3D(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglIsEnabledFrameLockI3D(System.IntPtr,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="pFlag"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglQueryFrameLockMasterI3D(System.IntPtr,System.Int32@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="pFlag"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetFrameUsageI3D(System.IntPtr,System.Single@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="pUsage"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglBeginFrameTrackingI3D(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglEndFrameTrackingI3D(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglQueryFrameTrackingI3D(System.IntPtr,System.Int32@,System.Int32@,System.Single@)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="pFrameCount"></param>
            <param name="pMissedFrames"></param>
            <param name="pLastMissedUsage"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglAllocateMemoryNV(System.IntPtr,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="size"></param>
            <param name="readFrequency"></param>
            <param name="writeFrequency"></param>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglFreeMemoryNV(System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <param name="pointer"></param>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetSyncValuesOML(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglGetMscRateOML(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSwapBuffersMscOML(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglSwapLayerBuffersMscOML(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglWaitForMscOML(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.wglWaitForSbcOML(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="extensionPointer"></param>
            <returns></returns>
        </member>
        <member name="T:Tao.Platform.Windows.WinNt">
            <summary>
                WinNT binding for .NET, implementing Windows NT-specific functionality.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_386">
            <summary>
                Intel i386 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_486">
            <summary>
                Intel i486 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_PENTIUM">
            <summary>
                Intel Pentium processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_IA64">
            <summary>
                Intel IA64 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_AMD_X8664">
            <summary>
                AMD X86 64 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_MIPS_R4000">
            <summary>
                MIPS R4000, R4101, R3910 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ALPHA_21064">
            <summary>
                Alpha 210 64 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_PPC_601">
            <summary>
                PPC 601 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_PPC_603">
            <summary>
                PPC 603 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_PPC_604">
            <summary>
                PPC 604 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_PPC_620">
            <summary>
                PPC 620 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_HITACHI_SH3">
            <summary>
                Hitachi SH3 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_HITACHI_SH3E">
            <summary>
                Hitachi SH3E processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_HITACHI_SH4">
            <summary>
                Hitachi SH4 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_MOTOROLA_821">
            <summary>
                Motorola 821 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_SHx_SH3">
            <summary>
                SHx SH3 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_SHx_SH4">
            <summary>
                SHx SH4 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_STRONGARM">
            <summary>
                StrongARM processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARM720">
            <summary>
                ARM 720 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARM820">
            <summary>
                ARM 820 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARM920">
            <summary>
                ARM 920 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARM_7TDMI">
            <summary>
                ARM 7TDMI processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_OPTIL">
            <summary>
                MSIL processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_INTEL">
            <summary>
                Intel architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_MIPS">
            <summary>
                MIPS architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_ALPHA">
            <summary>
                Alpha architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_PPC">
            <summary>
                PPC architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_SHX">
            <summary>
                SHX architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_ARM">
            <summary>
                ARM architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_IA64">
            <summary>
                IA64 architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_ALPHA64">
            <summary>
                Alpha64 architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_MSIL">
            <summary>
                MSIL architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_AMD64">
            <summary>
                AMD64 architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_IA32_ON_WIN64">
            <summary>
                IA32 On Win64 architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_UNKNOWN">
            <summary>
                Unknown architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_FLOATING_POINT_PRECISION_ERRATA">
            <summary>
                In rare circumstances, on a Pentium, a floating-point precision error can occur.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_FLOATING_POINT_EMULATED">
            <summary>
                Floating-point operations are emulated using a software emulator.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_COMPARE_EXCHANGE_DOUBLE">
            <summary>
                The compare and exchange double operation is available (Pentium, MIPS, and Alpha).
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_MMX_INSTRUCTIONS_AVAILABLE">
            <summary>
                The MMX instruction set is available.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_PPC_MOVEMEM_64BIT_OK">
            <summary>
                Unknown.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_ALPHA_BYTE_INSTRUCTIONS">
            <summary>
                Unknown.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_XMMI_INSTRUCTIONS_AVAILABLE">
            <summary>
                The SSE instruction set is available.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_3DNOW_INSTRUCTIONS_AVAILABLE">
            <summary>
                The 3D-Now instruction set is available.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_RDTSC_INSTRUCTION_AVAILABLE">
            <summary>
                The RDTSC instruction is available.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_PAE_ENABLED">
            <summary>
                The processor is PAE-enabled.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_XMMI64_INSTRUCTIONS_AVAILABLE">
            <summary>
                The SSE2 instruction set is available.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.WinNt.#ctor">
            <summary>
                Prevents instantiation.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Winmm">
            <summary>
                Windows Multimedia binding for .NET, implementing Windows-specific multimedia
                functionality.
            </summary>
            <remarks>
                Binds functions and definitions in winmm.dll.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.WINMM_NATIVE_LIBRARY">
            <summary>
                Specifies Winmm's native library archive.
            </summary>
            <remarks>
                Specifies winmm.dll for Windows.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.StdCall"/>.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_SYNC">
            <summary>
                Synchronous playback of a sound event.  <b>PlaySound</b> returns after the sound
                event completes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_ASYNC">
            <summary>
                The sound is played asynchronously and <b>PlaySound</b> returns immediately after
                beginning the sound.  To terminate an asynchronously played waveform sound, call
                <b>PlaySound</b> with <i>sound</i> set to NULL.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_NODEFAULT">
            <summary>
                No default sound event is used.  If the sound cannot be found, <b>PlaySound</b>
                returns silently without playing the default sound.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_MEMORY">
            <summary>
                A sound event's file is loaded in RAM.  The parameter specified by <i>sound</i>
                must point to an image of a sound in memory.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_LOOP">
            <summary>
                The sound plays repeatedly until <b>PlaySound</b> is called again with the
                <i>sound</i> parameter set to NULL.  You must also specify the
                <see cref="F:Tao.Platform.Windows.Winmm.SND_ASYNC"/> flag to indicate an asynchronous sound event.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_NOSTOP">
            <summary>
                <para>
                    The specified sound event will yield to another sound event that is already
                    playing.  If a sound cannot be played because the resource needed to
                    generate that sound is busy playing another sound, the function immediately
                    returns FALSE without playing the requested sound.
                </para>
                <para>
                    If this flag is not specified, <b>PlaySound</b> attempts to stop the currently
                    playing sound so that the device can be used to play the new sound.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_NOWAIT">
            <summary>
                If the driver is busy, return immediately without playing the sound.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_ALIAS">
            <summary>
                The <i>sound</i> parameter is a system-event alias in the registry or the WIN.INI
                file.  Do not use with either <see cref="F:Tao.Platform.Windows.Winmm.SND_FILENAME"/> or
                <see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/>.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_ALIAS_ID">
            <summary>
                The <i>sound</i> parameter is a predefined sound identifier.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_FILENAME">
            <summary>
                The <i>sound</i> parameter is a filename.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_RESOURCE">
            <summary>
                The <i>sound</i> parameter is a resource identifier; <i>mod</i> must identify the
                instance that contains the resource.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_PURGE">
            <summary>
                <para>
                    Sounds are to be stopped for the calling task.  If <i>sound</i> is not
                    NULL, all instances of the specified sound are stopped.  If <i>sound</i> is
                    NULL, all sounds that are playing on behalf of the calling task are stopped.
                </para>
                <para>
                    You must also specify the instance handle to stop <see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/>
                    events.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_APPLICATION">
            <summary>
                The sound is played using an application-specific association.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.TIMERR_BASE">
            <summary>
                Timer base identifier.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.TIMERR_NOERROR">
            <summary>
                Successful.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.TIMERR_NOCANDO">
            <summary>
                Resolution specified is out of range.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.#ctor">
            <summary>
                Prevents instantiation.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.PlaySound(System.String,System.IntPtr,System.Int32)">
            <summary>
                The <b>PlaySound</b> function plays a sound specified by the given filename,
                resource, or system event.  (A system event may be associated with a sound in the
                registry or in the WIN.INI file.)
            </summary>
            <param name="sound">
                <para>
                    A string that specifies the sound to play.  If this parameter is NULL, any
                    currently playing waveform sound is stopped.  To stop a non-waveform sound,
                    specify <see cref="F:Tao.Platform.Windows.Winmm.SND_PURGE"/> in the <i>soundFlags</i> parameter.
                </para>
                <para>
                    Three flags in <i>soundFlags</i> (<see cref="F:Tao.Platform.Windows.Winmm.SND_ALIAS"/>,
                    <see cref="F:Tao.Platform.Windows.Winmm.SND_FILENAME"/>, and <see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/>) determine
                    whether the name is interpreted as an alias for a system event, a filename, or
                    a resource identifier.  If none of these flags are specified, <b>PlaySound</b>
                    searches the registry or the WIN.INI file for an association with the
                    specified sound name.  If an association is found, the sound event is played.
                    If no association is found in the registry, the name is interpreted as a
                    filename.
                </para>
            </param>
            <param name="mod">
                Handle to the executable file that contains the resource to be loaded.  This
                parameter must be NULL unless <see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/> is specified in
                <i>soundFlags</i>.
            </param>
            <param name="soundFlags">
                <para>
                    Flags for playing the sound.  The following values are defined:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_APPLICATION"/></term>
                            <description>
                                The sound is played using an application-specific association.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_ALIAS"/></term>
                            <description>
                                The <i>sound</i> parameter is a system-event alias in the registry
                                or the WIN.INI file.  Do not use with either
                                <see cref="F:Tao.Platform.Windows.Winmm.SND_FILENAME"/> or <see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/>.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_ALIAS_ID"/></term>
                            <description>
                                The <i>sound</i> parameter is a predefined sound identifier.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_ASYNC"/></term>
                            <description>
                                The sound is played asynchronously and <b>PlaySound</b> returns
                                immediately after beginning the sound.  To terminate an
                                asynchronously played waveform sound, call <b>PlaySound</b> with
                                <i>sound</i> set to NULL.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_FILENAME"/></term>
                            <description>
                                The <i>sound</i> parameter is a filename.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_LOOP"/></term>
                            <description>
                                The sound plays repeatedly until <b>PlaySound</b> is called again
                                with the <i>sound</i> parameter set to NULL.  You must also
                                specify the <see cref="F:Tao.Platform.Windows.Winmm.SND_ASYNC"/> flag to indicate an
                                asynchronous sound event.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_MEMORY"/></term>
                            <description>
                                A sound event's file is loaded in RAM.  The parameter specified by
                                <i>sound</i> must point to an image of a sound in memory.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_NODEFAULT"/></term>
                            <description>
                                No default sound event is used.  If the sound cannot be found,
                                <b>PlaySound</b> returns silently without playing the default
                                sound.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_NOSTOP"/></term>
                            <description>
                                <para>
                                    The specified sound event will yield to another sound event
                                    that is already playing.  If a sound cannot be played because
                                    the resource needed to generate that sound is busy playing
                                    another sound, the function immediately returns FALSE without
                                    playing the requested sound.
                                </para>
                                <para>
                                    If this flag is not specified, <b>PlaySound</b> attempts to
                                    stop the currently playing sound so that the device can be
                                    used to play the new sound.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_NOWAIT"/></term>
                            <description>
                                If the driver is busy, return immediately without playing the
                                sound.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_PURGE"/></term>
                            <description>
                                <para>
                                    Sounds are to be stopped for the calling task.  If
                                    <i>sound</i> is not NULL, all instances of the specified sound
                                    are stopped.  If <i>sound</i> is NULL, all sounds that are
                                    playing on behalf of the calling task are stopped.
                                </para>
                                <para>
                                    You must also specify the instance handle to stop
                                    <see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/> events.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/></term>
                            <description>
                                The <i>sound</i> parameter is a resource identifier; <i>mod</i>
                                must identify the instance that contains the resource.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_SYNC"/></term>
                            <description>
                                Synchronous playback of a sound event.  <b>PlaySound</b> returns
                                after the sound event completes.
                            </description>
                        </item>
                    </list>
                </para>
            </param>
            <returns>
                Returns TRUE if successful or FALSE otherwise.
            </returns>
            <remarks>
                <para>
                    The sound specified by <i>sound</i> must fit into available physical memory
                    and be playable by an installed waveform-audio device driver.
                    <b>PlaySound</b> searches the following directories for sound files: the
                    current directory; the Windows directory; the Windows system directory;
                    directories listed in the PATH environment variable; and the list of
                    directories mapped in a network.  For more information about the directory
                    search order, see the documentation for the <b>OpenFile</b> function.
                </para>
                <para>
                    If it cannot find the specified sound, <b>PlaySound</b> uses the default
                    system event sound entry instead.  If the function can find neither the
                    system default entry nor the default sound, it makes no sound and returns
                    FALSE.
                </para>
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)">
            <summary>
                The <b>timeBeginPeriod</b> function sets the minimum timer resolution for an
                application or device driver.
            </summary>
            <param name="period">
                Minimum timer resolution, in milliseconds, for the application or device driver.
            </param>
            <returns>
                Returns <see cref="F:Tao.Platform.Windows.Winmm.TIMERR_NOERROR"/> if successful or
                <see cref="F:Tao.Platform.Windows.Winmm.TIMERR_NOCANDO"/> if the resolution specified in <i>period</i> is out
                of range.
            </returns>
            <remarks>
                <para>
                    Call this function immediately before using timer services, and call the
                    <see cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/> function immediately after you are finished
                    using the timer services.
                </para>
                <para>
                    You must match each call to <b>timeBeginPeriod</b> with a call to
                    <see cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/>, specifying the same minimum resolution in both
                    calls.  An application can make multiple <b>timeBeginPeriod</b> calls as long
                    as each call is matched with a call to <see cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/>.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)">
            <summary>
                The <b>timeEndPeriod</b> function clears a previously set minimum timer
                resolution.
            </summary>
            <param name="period">
                Minimum timer resolution specified in the previous call to the
                <see cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/> function.
            </param>
            <returns>
                Returns <see cref="F:Tao.Platform.Windows.Winmm.TIMERR_NOERROR"/> if successful or
                <see cref="F:Tao.Platform.Windows.Winmm.TIMERR_NOCANDO"/> if the resolution specified in <i>period</i> is out
                of range
            </returns>
            <remarks>
                <para>
                    Call this function immediately after you are finished using timer services.
                </para>
                <para>
                    You must match each call to <see cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/> with a call to
                    <b>timeEndPeriod</b>, specifying the same minimum resolution in both calls.
                    An application can make multiple <see cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/> calls as long
                    as each call is matched with a call to <b>timeEndPeriod</b>.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.timeGetTime">
            <summary>
                The <b>timeGetTime</b> function retrieves the system time, in milliseconds.
                The system time is the time elapsed since Windows was started.
            </summary>
            <returns>
                Returns the system time, in milliseconds.
            </returns>
            <remarks>
                <para>
                    The only difference between this function and the <b>timeGetSystemTime</b>
                    function is that <b>timeGetSystemTime</b> uses the <b>MMTIME</b> structure to
                    return the system time.  The <b>timeGetTime</b> function has less overhead
                    than <b>timeGetSystemTime</b>.
                </para>
                <para>
                    Note that the value returned by the <b>timeGetTime</b> function is a DWORD
                    value.  The return value wraps around to 0 every 2^32 milliseconds, which is
                    about 49.71 days.  This can cause problems in code that directly uses the
                    <b>timeGetTime</b> return value in computations, particularly where the value
                    is used to control code execution.  You should always use the difference
                    between two <b>timeGetTime</b> return values in computations.
                </para>
                <para>
                    <b>Windows NT/2000:</b> The default precision of the <b>timeGetTime</b>
                    function can be five milliseconds or more, depending on the machine.  You
                    can use the <see cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/> and <see cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/>
                    functions to increase the precision of <b>timeGetTime</b>.  If you do so, the
                    minimum difference between successive values returned by <b>timeGetTime</b>
                    can be as large as the minimum period value set using
                    <see cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/> and <see cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/>.  Use the
                    <see cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounter(System.Int64@)"/> and
                    <see cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceFrequency(System.Int64@)"/> functions to measure short
                    time intervals at a high resolution.
                </para>
                <para>
                    <b>Windows 95:</b> The default precision of the <b>timeGetTime</b> function is
                    1 millisecond.  In other words, the <b>timeGetTime</b> function can return
                    successive values that differ by just 1 millisecond.  This is true no matter
                    what calls have been made to the <b>timeBeginPeriod</b> and
                    <b>timeEndPeriod</b> functions.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounter(System.Int64@)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceFrequency(System.Int64@)"/>
            <seealso cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/>
        </member>
    </members>
</doc>
